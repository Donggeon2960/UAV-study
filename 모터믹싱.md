# UAV 3주차 PPT - 모터 믹싱 알고리즘 완전판

PID 제어 다음 단계: 토크 명령을 실제 모터 출력으로 변환

---

# 슬라이드 21: 모터 믹싱 알고리즘 개요

## 제목
**알고리즘 2: 모터 믹싱 (Motor Mixing)**

## 부제목
PID 출력을 4개 모터 PWM으로 변환

---

## 왼쪽 영역: 역할 설명

```
┌──────────────────────────────────────┐
│ 입력 (PID 출력)                       │
├──────────────────────────────────────┤
│ • Roll 토크:    0.3                  │
│ • Pitch 토크:   0.5                  │
│ • Yaw 토크:     0.1                  │
│ • Thrust:       0.6                  │
└──────────────────────────────────────┘
           ↓
    [모터 믹싱 알고리즘]
           ↓
┌──────────────────────────────────────┐
│ 출력 (4개 모터 PWM)                   │
├──────────────────────────────────────┤
│ • M1 (전방 우):  1250 μs            │
│ • M2 (후방 좌):  1580 μs            │
│ • M3 (전방 좌):  1420 μs            │
│ • M4 (후방 우):  1180 μs            │
└──────────────────────────────────────┘
```

---

## 중단: 핵심 역할

### 📌 3가지 주요 기능

**1. 토크 → 추력 변환**
- Roll/Pitch/Yaw 토크를 4개 모터 추력으로 분배
- 믹싱 행렬 사용

**2. 정규화 (Normalization)**
- 모터 출력 합 = 1.0 유지
- 과포화 방지

**3. PWM 변환**
- 0~1 값을 1000~2000 μs PWM으로 변환
- ESC가 이해하는 신호 생성

---

## 오른쪽 영역: 쿼드콥터 모터 배치

```
      전방 (Forward)
          ↑
    
    M3 ⟲     ⟳ M1
      ╲       ╱
       ╲     ╱
        ╲   ╱
         ╲ ╱
          X
         ╱ ╲
        ╱   ╲
       ╱     ╲
      ╱       ╲
    M2 ⟳     ⟲ M4

모터 회전 방향:
M1, M4: CW  (시계방향 ⟳)
M2, M3: CCW (반시계방향 ⟲)
```

**X-프레임 구성**
- 대각선 모터 쌍이 같은 방향
- 반작용 토크 상쇄

---

## 하단: 실행 특성

```
┌────────────────────────────────────┐
│ 실행 주파수                         │
├────────────────────────────────────┤
│ 250 ~ 490 Hz                       │
│ (보통 400 Hz)                      │
│                                    │
│ Rate Controller(1000Hz)보다 느림   │
│ 이유: ESC 업데이트 속도 제한        │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 위치                               │
├────────────────────────────────────┤
│ PX4: src/modules/                  │
│      mavlink/streams/mixer.cpp     │
│                                    │
│ ArduPilot: libraries/AP_Motors/    │
│            AP_MotorsMatrix.cpp     │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"PID 제어기가 Roll, Pitch, Yaw 토크와 Thrust를 계산하면, 모터 믹싱 알고리즘이 이를 4개 모터의 구체적인 PWM 신호로 변환합니다.

예를 들어 Roll 토크 0.3, Pitch 토크 0.5, Yaw 토크 0.1, Thrust 0.6이라는 추상적인 값이 들어오면, M1은 1250 마이크로초, M2는 1580 마이크로초 같은 구체적인 PWM 신호로 변환됩니다.

쿼드콥터는 X-프레임 구성으로, 대각선 모터가 같은 방향으로 회전합니다. M1과 M4는 시계방향, M2와 M3는 반시계방향으로 회전하여 반작용 토크를 상쇄합니다.

이 알고리즘은 보통 400Hz로 실행되며, Rate Controller보다는 느리지만 ESC 업데이트 속도에 맞춰져 있습니다."

---

## 이미지/다이어그램 추천

1. **쿼드콥터 3D 모델**: 모터 위치와 회전 방향 표시
2. **데이터 흐름**: PID → 믹싱 → PWM → 모터
3. **모터 배치 도면**: 정확한 각도와 거리

---
---

# 슬라이드 22: 물리적 원리 - 힘과 토크

## 제목
**모터 믹싱의 물리학**

## 부제목
4개 모터로 6자유도 제어 (3개만 독립)

---

## 상단: 6자유도 vs 4개 모터

```
┌──────────────────────────────────────┐
│ 6자유도 (Degrees of Freedom)         │
├──────────────────────────────────────┤
│ 1. X축 이동 (전후)                    │
│ 2. Y축 이동 (좌우)                    │
│ 3. Z축 이동 (상하) ✓                 │
│ 4. Roll (X축 회전) ✓                 │
│ 5. Pitch (Y축 회전) ✓                │
│ 6. Yaw (Z축 회전) ✓                  │
└──────────────────────────────────────┘

4개 모터 = 4개 독립 변수
→ 4개 자유도만 직접 제어 가능

✓ 표시: 직접 제어 가능
   (Z, Roll, Pitch, Yaw)

X/Y 이동: 간접 제어
  (Pitch/Roll로 기울여서 이동)
```

---

## 중단 왼쪽: Roll 토크 생성

```
        전방
         ↑
    
   M3↓      ↑M1
     ╲       ╱
      ╲     ╱
       ╲   ╱
        ╲ ╱
         X
        ╱ ╲
       ╱   ╲
      ╱     ╲
     ╱       ╲
   M2↑      ↓M4

Roll 우측 (↻):
- M1, M2: 증가 ↑
- M3, M4: 감소 ↓

결과: 드론이 우측으로 기울어짐
```

**수식:**
```
τ_roll = L × (F_M1 - F_M3 + F_M2 - F_M4)

L: 모터 간 거리 (arm length)
F: 각 모터 추력
```

---

## 중단 중앙: Pitch 토크 생성

```
        전방
         ↑
    
   M3↓      ↓M1
     ╲       ╱
      ╲     ╱
       ╲   ╯
        ╲ ╱
         X
        ╱ ╲
       ╱   ╲
      ╱     ╲
     ╱       ╲
   M2↑      ↑M4

Pitch 전방 (↻):
- M1, M3: 감소 ↓
- M2, M4: 증가 ↑

결과: 드론이 전방으로 기울어짐
```

**수식:**
```
τ_pitch = L × (F_M2 - F_M1 + F_M4 - F_M3)
```

---

## 중단 오른쪽: Yaw 토크 생성

```
        전방
         ↑
    
   M3↓⟲    ↑⟳M1
     ╲       ╱
      ╲     ╱
       ╲   ╱
        ╲ ╱
         X
        ╱ ╲
       ╱   ╲
      ╱     ╲
     ╱       ╲
   M2↑⟳    ↓⟲M4

Yaw 우측 (↻):
- CW 모터(M1,M4): 증가 ↑
- CCW 모터(M2,M3): 감소 ↓

결과: 드론이 시계방향 회전
```

**수식:**
```
τ_yaw = k_M × (F_M1 - F_M2 - F_M3 + F_M4)

k_M: 모터 토크 상수
```

---

## 하단: Thrust (추력) 생성

```
    M3↑      ↑M1
      ╲     ╱
       ╲   ╱
        ╲ ╱
         X ↑↑↑ (상승)
        ╱ ╲
       ╱   ╲
      ╱     ╲
    M2↑      ↑M4

Thrust 증가:
- 모든 모터: 동일하게 증가 ↑↑↑↑

결과: 드론이 수직 상승
```

**수식:**
```
T_total = F_M1 + F_M2 + F_M3 + F_M4
```

---

## 핵심 원리 요약

```
┌────────────────────────────────────┐
│ 핵심 아이디어                       │
├────────────────────────────────────┤
│ • 대칭 모터 쌍: 균형 제어           │
│ • 비대칭 추력: 토크 생성            │
│ • 모든 모터 동일: Thrust            │
│                                    │
│ 수학적으로:                         │
│ Roll  = (M1 - M3) + (M2 - M4)      │
│ Pitch = (M2 - M1) + (M4 - M3)      │
│ Yaw   = (M1 - M2) - (M3 - M4)      │
│ Thrust= M1 + M2 + M3 + M4          │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"쿼드콥터는 4개 모터로 6자유도 중 4개를 직접 제어합니다. X/Y 방향 이동은 Pitch와 Roll로 기울여서 간접적으로 제어하죠.

Roll 토크를 생성하려면 좌우 모터의 추력을 다르게 합니다. M1과 M2를 증가시키고 M3과 M4를 감소시키면 드론이 우측으로 기울어집니다. 이때 토크는 모터 간 거리 L에 추력 차이를 곱한 값입니다.

Pitch는 전후 모터의 차이로 만들고, Yaw는 시계/반시계 모터의 차이로 만듭니다. Yaw가 특별한 이유는 모터의 반작용 토크를 이용하기 때문입니다.

Thrust는 단순합니다. 모든 모터를 동일하게 증가시키면 드론이 수직으로 상승합니다."

---
---

# 슬라이드 23: 믹싱 행렬 (Mixing Matrix)

## 제목
**믹싱 행렬: 수학적 표현**

## 부제목
4×4 행렬로 한 번에 계산

---

## 상단: 행렬 수식

### X-프레임 (대각선 구성)

```
┌───┐   ┌                              ┐ ┌─────────┐
│M1 │   │ +1   -1   -1   +1            │ │ Thrust  │
│M2 │ = │ +1   +1   +1   -1            │ │ Roll    │
│M3 │   │ +1   +1   -1   +1            │ │ Pitch   │
│M4 │   │ +1   -1   +1   -1            │ │ Yaw     │
└───┘   └                              ┘ └─────────┘

설명:
각 행 = 하나의 모터
각 열 = Thrust / Roll / Pitch / Yaw
```

---

## 중단 왼쪽: 행렬 해석

### M1 (전방 우)의 계산

```
M1 = (+1)×Thrust  → 추력에 기여
     +(-1)×Roll   → Roll 우측 시 감소
     +(-1)×Pitch  → Pitch 전방 시 감소
     +(+1)×Yaw    → Yaw 우측 시 증가

예시:
Thrust = 0.6, Roll = 0.2
Pitch = 0.3, Yaw = 0.1

M1 = 0.6 - 0.2 - 0.3 + 0.1
   = 0.2
```

---

## 중단 오른쪽: 부호 규칙

```
┌────────────────────────────────────┐
│ Thrust 열 (모두 +1)                 │
├────────────────────────────────────┤
│ 모든 모터가 추력에 양수로 기여      │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ Roll 열                             │
├────────────────────────────────────┤
│ 우측 모터(M1,M4): -1               │
│ 좌측 모터(M2,M3): +1               │
│                                    │
│ Roll 우측 명령(+) → 우측 모터 감소  │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ Pitch 열                            │
├────────────────────────────────────┤
│ 전방 모터(M1,M3): -1               │
│ 후방 모터(M2,M4): +1               │
│                                    │
│ Pitch 전방 명령(+) → 전방 모터 감소 │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ Yaw 열                              │
├────────────────────────────────────┤
│ CW 모터(M1,M4):  +1                │
│ CCW 모터(M2,M3): -1                │
│                                    │
│ Yaw 우측 명령(+) → CW 모터 증가     │
└────────────────────────────────────┘
```

---

## 하단 왼쪽: +-프레임 비교

### +-프레임 (십자 구성)

```
        M1
         │
         │
    M3 ──┼── M4
         │
         │
        M2

믹싱 행렬:
┌───┐   ┌                    ┐ ┌─────────┐
│M1 │   │ +1    0   -1   +1  │ │ Thrust  │
│M2 │ = │ +1    0   +1   -1  │ │ Roll    │
│M3 │   │ +1   +1    0   +1  │ │ Pitch   │
│M4 │   │ +1   -1    0   -1  │ │ Yaw     │
└───┘   └                    ┘ └─────────┘

차이점:
- M1, M2: Roll에 영향 없음 (0)
- M3, M4: Pitch에 영향 없음 (0)
```

---

## 하단 오른쪽: 실제 코드

```cpp
// X-프레임 믹싱 행렬
const float MIXER_MATRIX[4][4] = {
    // Thr   Roll  Pitch  Yaw
    { +1.0f, -1.0f, -1.0f, +1.0f },  // M1
    { +1.0f, +1.0f, +1.0f, -1.0f },  // M2
    { +1.0f, +1.0f, -1.0f, +1.0f },  // M3
    { +1.0f, -1.0f, +1.0f, -1.0f }   // M4
};

// 믹싱 계산
for (int i = 0; i < 4; i++) {
    motor[i] = 
        MIXER_MATRIX[i][0] * thrust +
        MIXER_MATRIX[i][1] * roll +
        MIXER_MATRIX[i][2] * pitch +
        MIXER_MATRIX[i][3] * yaw;
}
```

---

## 발표 스크립트

"믹싱 행렬은 4개 입력(Thrust, Roll, Pitch, Yaw)을 4개 출력(M1, M2, M3, M4)으로 변환하는 4×4 행렬입니다.

각 행은 하나의 모터를 나타내고, 각 열은 입력 명령을 나타냅니다. 예를 들어 M1의 행은 +1, -1, -1, +1인데, 이는 Thrust에는 양수로 기여하고, Roll 우측 명령 시에는 감소하며, Pitch 전방 명령 시에도 감소하고, Yaw 우측 명령 시에는 증가한다는 의미입니다.

부호 규칙이 중요합니다. Roll 우측 명령(+)이 들어오면 우측 모터는 감소해야 드론이 우측으로 기울어집니다. 이것이 -1인 이유입니다.

X-프레임과 +-프레임은 다른 믹싱 행렬을 사용합니다. X-프레임은 모든 모터가 4개 입력에 모두 기여하지만, +-프레임은 일부 모터가 특정 입력에 0으로 기여합니다."

---
---

# 슬라이드 24: 완전한 코드 구현 (Part 1)

## 제목
**모터 믹싱 완전한 코드 (1/2)**

## 부제목
기본 믹싱 계산

---

## 상단: 역할 설명

```
┌────────────────────────────────────┐
│ 파일: AP_MotorsMatrix.cpp           │
│ 위치: ArduPilot/libraries/AP_Motors│
│ 함수: output_armed_stabilizing()   │
└────────────────────────────────────┘
```

---

## 중단: 코드 Part 1

```cpp
void AP_MotorsMatrix::output_armed_stabilizing()
{
    // ═══════════════════════════════════════
    // Step 1: PID 출력 받기
    // ═══════════════════════════════════════
    float roll_thrust = _roll_in;   // -1.0 ~ +1.0
    float pitch_thrust = _pitch_in;
    float yaw_thrust = _yaw_in;
    float throttle = _throttle_in;  // 0.0 ~ 1.0
    
    // 📖 예시:
    // roll_thrust = 0.3  (우측으로 기울임)
    // pitch_thrust = 0.5 (전방으로 기울임)
    // yaw_thrust = 0.1   (시계방향 회전)
    // throttle = 0.6     (60% 추력)
    
    
    // ═══════════════════════════════════════
    // Step 2: 스로틀 범위 조정
    // ═══════════════════════════════════════
    float thr_avg_max = constrain_float(
        throttle, 
        throttle_avg_max, 
        _throttle_thrust_max
    );
    
    // 📖 의미:
    // 기본 스로틀은 그대로 사용하되,
    // 최대값을 제한하여 제어 여유 확보
    
    
    // ═══════════════════════════════════════
    // Step 3: 각 모터 계산
    // ═══════════════════════════════════════
    for (int i = 0; i < AP_MOTORS_MAX_NUM_MOTORS; i++) {
        
        if (motor_enabled[i]) {
            
            // 믹싱 행렬 적용
            _thrust_rpyt_out[i] = 
                roll_thrust  * _roll_factor[i] +
                pitch_thrust * _pitch_factor[i] +
                yaw_thrust   * _yaw_factor[i] +
                throttle;
            
            // 📖 예시 (M1):
            // _roll_factor[0]  = -1.0
            // _pitch_factor[0] = -1.0
            // _yaw_factor[0]   = +1.0
            //
            // _thrust_rpyt_out[0] = 
            //     0.3 × (-1.0) +
            //     0.5 × (-1.0) +
            //     0.1 × (+1.0) +
            //     0.6
            //   = -0.3 - 0.5 + 0.1 + 0.6
            //   = -0.1
            
            // 🔍 의미:
            // M1은 Roll 우측(-), Pitch 전방(-)으로
            // 추력이 감소하고, Yaw 우측(+)으로 증가
        }
    }
    
    
    // ═══════════════════════════════════════
    // Step 4: 4개 모터 결과
    // ═══════════════════════════════════════
    // M1 (전방 우): -0.1
    // M2 (후방 좌): +1.5
    // M3 (전방 좌): +0.9
    // M4 (후방 우): -0.3
    
    // ⚠️ 문제: M1, M4가 음수!
    //    물리적으로 불가능 (모터는 역회전 불가)
    //
    // → 다음 단계: 정규화 필요
}
```

---

## 하단: 각 Factor 배열

```cpp
// X-프레임 설정 (setup 시 초기화)
_roll_factor[0]  = -1.0f;  // M1
_roll_factor[1]  = +1.0f;  // M2
_roll_factor[2]  = +1.0f;  // M3
_roll_factor[3]  = -1.0f;  // M4

_pitch_factor[0] = -1.0f;  // M1
_pitch_factor[1] = +1.0f;  // M2
_pitch_factor[2] = -1.0f;  // M3
_pitch_factor[3] = +1.0f;  // M4

_yaw_factor[0]   = +1.0f;  // M1 (CW)
_yaw_factor[1]   = -1.0f;  // M2 (CCW)
_yaw_factor[2]   = +1.0f;  // M3 (CCW)
_yaw_factor[3]   = -1.0f;  // M4 (CW)
```

---

## 발표 스크립트

"실제 ArduPilot 코드를 봅시다. Step 1에서 PID 출력을 받습니다. Roll, Pitch, Yaw는 -1~+1 범위이고, Throttle은 0~1 범위입니다.

Step 2에서는 스로틀 범위를 조정합니다. 최대값을 제한하는 이유는 제어 여유를 확보하기 위함입니다. 만약 스로틀이 100%이면 Roll/Pitch 제어를 위한 여유가 없어집니다.

Step 3에서 각 모터를 계산합니다. M1을 예로 들면, Roll factor -1.0, Pitch factor -1.0, Yaw factor +1.0을 곱해서 더합니다. 결과는 -0.1입니다.

그런데 문제가 있습니다. M1이 -0.1, M4가 -0.3으로 음수가 나왔습니다. 물리적으로 모터는 역회전이 불가능하므로 이를 해결하는 정규화가 필요합니다."

---
---

# 슬라이드 25: 완전한 코드 구현 (Part 2)

## 제목
**모터 믹싱 완전한 코드 (2/2)**

## 부제목
정규화 및 PWM 변환

---

## 상단: 정규화 (Normalization)

```cpp
    // ═══════════════════════════════════════
    // Step 5: 최소/최대값 찾기
    // ═══════════════════════════════════════
    float min_out = _thrust_rpyt_out[0];
    float max_out = _thrust_rpyt_out[0];
    
    for (int i = 1; i < 4; i++) {
        if (_thrust_rpyt_out[i] < min_out) {
            min_out = _thrust_rpyt_out[i];
        }
        if (_thrust_rpyt_out[i] > max_out) {
            max_out = _thrust_rpyt_out[i];
        }
    }
    
    // 📖 예시:
    // M1 = -0.1, M2 = +1.5, M3 = +0.9, M4 = -0.3
    // min_out = -0.3
    // max_out = +1.5
    
    
    // ═══════════════════════════════════════
    // Step 6: 음수 제거 (상향 이동)
    // ═══════════════════════════════════════
    if (min_out < 0.0f) {
        // 모든 모터에 |min_out| 더하기
        float boost = -min_out;
        
        for (int i = 0; i < 4; i++) {
            _thrust_rpyt_out[i] += boost;
        }
        
        // 📖 예시:
        // boost = 0.3
        // M1 = -0.1 + 0.3 = 0.2
        // M2 = +1.5 + 0.3 = 1.8
        // M3 = +0.9 + 0.3 = 1.2
        // M4 = -0.3 + 0.3 = 0.0
        
        // ✓ 음수 제거 완료
    }
    
    
    // ═══════════════════════════════════════
    // Step 7: 최대값 제한 (스케일 다운)
    // ═══════════════════════════════════════
    max_out = _thrust_rpyt_out[0];
    for (int i = 1; i < 4; i++) {
        if (_thrust_rpyt_out[i] > max_out) {
            max_out = _thrust_rpyt_out[i];
        }
    }
    
    if (max_out > 1.0f) {
        // 모든 모터를 비례적으로 감소
        float scale = 1.0f / max_out;
        
        for (int i = 0; i < 4; i++) {
            _thrust_rpyt_out[i] *= scale;
        }
        
        // 📖 예시:
        // max_out = 1.8
        // scale = 1.0 / 1.8 = 0.556
        //
        // M1 = 0.2 × 0.556 = 0.111
        // M2 = 1.8 × 0.556 = 1.000 (최대)
        // M3 = 1.2 × 0.556 = 0.667
        // M4 = 0.0 × 0.556 = 0.000 (최소)
        
        // ✓ 0.0 ~ 1.0 범위 달성
    }
```

---

## 중단: PWM 변환

```cpp
    // ═══════════════════════════════════════
    // Step 8: PWM 신호 생성
    // ═══════════════════════════════════════
    uint16_t pwm_min = 1000;  // 1000 μs (최소)
    uint16_t pwm_max = 2000;  // 2000 μs (최대)
    
    for (int i = 0; i < 4; i++) {
        // 0.0~1.0 → 1000~2000 μs 선형 변환
        uint16_t pwm = pwm_min + 
            (_thrust_rpyt_out[i] * (pwm_max - pwm_min));
        
        // ESC로 신호 출력
        rc_write(i, pwm);
        
        // 📖 예시:
        // M1: 0.111 → 1000 + (0.111×1000) = 1111 μs
        // M2: 1.000 → 1000 + (1.000×1000) = 2000 μs
        // M3: 0.667 → 1000 + (0.667×1000) = 1667 μs
        // M4: 0.000 → 1000 + (0.000×1000) = 1000 μs
    }
    
    // 🔍 의미:
    // M2가 최대 추력 (2000 μs)
    // M4가 최소 추력 (1000 μs, 거의 정지)
    // M1, M3은 중간 추력
```

---

## 하단: 정규화 효과

```
┌────────────────────────────────────┐
│ 정규화 전                           │
├────────────────────────────────────┤
│ M1 = -0.1  (불가능!)                │
│ M2 = +1.5  (과포화!)                │
│ M3 = +0.9                           │
│ M4 = -0.3  (불가능!)                │
└────────────────────────────────────┘
         ↓
    음수 제거 (boost)
         ↓
┌────────────────────────────────────┐
│ 음수 제거 후                        │
├────────────────────────────────────┤
│ M1 = 0.2                            │
│ M2 = 1.8  (여전히 과포화)           │
│ M3 = 1.2                            │
│ M4 = 0.0                            │
└────────────────────────────────────┘
         ↓
  스케일 다운 (scale)
         ↓
┌────────────────────────────────────┐
│ 최종 정규화                         │
├────────────────────────────────────┤
│ M1 = 0.111                          │
│ M2 = 1.000  ✓                      │
│ M3 = 0.667                          │
│ M4 = 0.000  ✓                      │
└────────────────────────────────────┘
```

**핵심:**
- 음수 → 0 이상으로 보정
- 최대값 → 1.0 이하로 스케일링
- **비율 유지** (제어 특성 보존)

---

## 발표 스크립트

"정규화는 2단계로 진행됩니다. 먼저 음수를 제거합니다. 최소값이 -0.3이면, 모든 모터에 0.3을 더합니다. 이렇게 하면 M1은 0.2, M2는 1.8, M3은 1.2, M4는 0.0이 됩니다.

하지만 M2가 1.8로 여전히 1.0을 초과합니다. Step 7에서는 최대값으로 나눠서 스케일 다운합니다. 1.8로 나누면 scale=0.556이 되고, 모든 모터에 곱합니다.

최종 결과는 M1=0.111, M2=1.000, M3=0.667, M4=0.000입니다. 모두 0~1 범위에 들어왔습니다.

중요한 것은 비율이 유지된다는 점입니다. M2가 가장 크고 M4가 가장 작다는 관계는 그대로 유지되므로, 원래 의도한 제어 특성이 보존됩니다.

Step 8에서는 0~1 값을 1000~2000 마이크로초 PWM 신호로 선형 변환합니다. M2는 2000 μs로 최대 추력, M4는 1000 μs로 최소 추력이 됩니다."

---
---

# 슬라이드 26: 실전 예시 - Roll 명령

## 제목
**실전 시나리오: Roll 우측 명령**

## 부제목
각 단계별 모터 출력 변화

---

## 시나리오: 우측으로 기울이기

```
명령:
- Roll: +0.5 (우측)
- Pitch: 0
- Yaw: 0
- Throttle: 0.5 (호버링)
```

---

## Step-by-Step 계산

### Step 1: 초기 믹싱

```
M1 = 0.5 + (-1.0)×0.5 + 0 + 0
   = 0.5 - 0.5 = 0.0

M2 = 0.5 + (+1.0)×0.5 + 0 + 0
   = 0.5 + 0.5 = 1.0

M3 = 0.5 + (+1.0)×0.5 + 0 + 0
   = 0.5 + 0.5 = 1.0

M4 = 0.5 + (-1.0)×0.5 + 0 + 0
   = 0.5 - 0.5 = 0.0

결과:
M1, M4 = 0.0 (우측 모터 최소)
M2, M3 = 1.0 (좌측 모터 최대)
```

---

## 시각화

```
        전방
         ↑
    
   M3━━━    ━━━M1
    1.0 ╲   ╱ 0.0
         ╲ ╱
          X  → (우측으로 기울어짐)
         ╱ ╲
    1.0 ╱   ╲ 0.0
   M2━━━    ━━━M4

좌측 모터(M2,M3): 최대 추력 ━━━
우측 모터(M1,M4): 최소 추력 ━━━

결과: 드론이 우측으로 기울어짐 ↻
```

---

## PWM 출력

```
M1: 0.0 → 1000 μs (최소, 거의 정지)
M2: 1.0 → 2000 μs (최대)
M3: 1.0 → 2000 μs (최대)
M4: 0.0 → 1000 μs (최소, 거의 정지)
```

---

## 물리적 효과

```
┌────────────────────────────────────┐
│ t=0.00s: 명령 수신                  │
├────────────────────────────────────┤
│ Roll = +0.5                         │
│ 목표: 우측으로 기울임               │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ t=0.01s: 모터 출력 변경             │
├────────────────────────────────────┤
│ M2, M3: 2000 μs (좌측 증가)         │
│ M1, M4: 1000 μs (우측 감소)         │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ t=0.05s: 드론 기울어짐 시작         │
├────────────────────────────────────┤
│ Roll 각도: 0° → 5°                  │
│ 각속도: 100 deg/s                   │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ t=0.20s: 목표 각도 도달             │
├────────────────────────────────────┤
│ Roll 각도: 28°                      │
│ 각속도: 0 deg/s (안정화)            │
│                                    │
│ Rate Controller가 목표 달성         │
│ → 모터 출력 재조정                  │
└────────────────────────────────────┘
```

---

## 다른 예시: Pitch 전방

```
명령:
- Roll: 0
- Pitch: +0.4 (전방)
- Yaw: 0
- Throttle: 0.5

결과:
M1 = 0.5 + 0 + (-1.0)×0.4 + 0 = 0.1
M2 = 0.5 + 0 + (+1.0)×0.4 + 0 = 0.9
M3 = 0.5 + 0 + (-1.0)×0.4 + 0 = 0.1
M4 = 0.5 + 0 + (+1.0)×0.4 + 0 = 0.9

시각화:
        전방
         ↑
    
   M3━━━    ━━━M1
    0.1 ╲   ╱ 0.1  (전방 감소)
         ╲ ╱
          X ↗ (전방으로 기울어짐)
         ╱ ╲
    0.9 ╱   ╲ 0.9  (후방 증가)
   M2━━━━━━━━━━M4
```

---

## 발표 스크립트

"실전 예시를 봅시다. Roll +0.5, 즉 우측으로 기울이는 명령이 들어왔습니다. Throttle은 0.5로 호버링 상태입니다.

믹싱 계산을 하면 M1과 M4는 0.0, M2와 M3는 1.0이 나옵니다. 이는 우측 모터는 최소 추력, 좌측 모터는 최대 추력이라는 의미입니다.

PWM으로 변환하면 M1, M4는 1000 μs로 거의 정지하고, M2, M3는 2000 μs로 최대 출력됩니다.

물리적으로는 0.05초 만에 드론이 기울어지기 시작하고, 0.2초 후에 목표 각도 28도에 도달합니다. Rate Controller가 목표를 달성하면 모터 출력을 재조정하여 그 각도를 유지합니다.

Pitch 전방 명령도 비슷합니다. 전방 모터(M1, M3)는 0.1로 감소하고, 후방 모터(M2, M4)는 0.9로 증가하여 드론이 전방으로 기울어집니다."

---
---

# 슬라이드 27: 모터 순서와 회전 방향

## 제목
**모터 순서 및 회전 방향 규약**

## 부제목
표준 넘버링과 프로펠러 방향

---

## 왼쪽: PX4/ArduPilot 표준

### X-프레임 넘버링

```
      전방 (Forward)
          ↑
    
    M3 ⟲     ⟳ M1
      ╲       ╱
       ╲     ╱
        ╲   ╱
         ╲ ╱
          X
         ╱ ╲
        ╱   ╲
       ╱     ╲
      ╱       ╲
    M2 ⟳     ⟲ M4

넘버링 규칙:
- 전방 우측부터 시작: M1
- 시계방향 순서: M1 → M4 → M2 → M3

회전 방향:
- M1, M4: CW  (시계방향 ⟳)
- M2, M3: CCW (반시계방향 ⟲)
```

---

## 중단: +-프레임 넘버링

```
        M1 ⟳
         │
         │
    M3 ⟲ ┼ ⟳ M4
         │
         │
        M2 ⟲

넘버링 규칙:
- 전방부터 시작: M1
- 시계방향 순서

회전 방향:
- M1, M4: CW  (⟳)
- M2, M3: CCW (⟲)
```

---

## 오른쪽: 회전 방향의 중요성

### 왜 대칭적으로 반대로 회전?

```
┌────────────────────────────────────┐
│ 뉴턴의 제3법칙 (작용-반작용)        │
├────────────────────────────────────┤
│                                    │
│ 모터가 프로펠러를 CW로 회전         │
│    ↓                               │
│ 반작용: 드론 본체가 CCW로 회전      │
│                                    │
│ 해결책:                            │
│ 대각선 모터 쌍을 같은 방향으로      │
│ → 반작용 토크 상쇄                  │
└────────────────────────────────────┘
```

### 토크 균형

```
M1(CW) + M4(CW) = 시계방향 토크
M2(CCW) + M3(CCW) = 반시계방향 토크

정상 비행:
  CW 토크 = CCW 토크
  → 순 토크 = 0
  → 드론이 회전하지 않음

Yaw 명령:
  CW 모터 증가, CCW 모터 감소
  → CW 토크 > CCW 토크
  → 드론이 시계방향 회전
```

---

## 하단: 모터 순서 확인 방법

### SITL 테스트

```bash
# PX4 SITL 모터 테스트
pxh> motor_test test -m 1 -p 30

# 결과: M1 모터가 30% 출력으로 회전
# 육안으로 확인:
# - 어느 모터가 회전하는가?
# - 어느 방향으로 회전하는가?
```

### 실제 드론 테스트

```
⚠️ 안전 수칙

1. 프로펠러 제거하고 테스트
2. 드론을 고정된 스탠드에 장착
3. 배터리 연결
4. GCS에서 모터 테스트 실행
5. 각 모터 번호와 위치 확인
6. 회전 방향 육안 확인
7. 프로펠러 장착 (방향 주의!)
   - CW 모터 → CW 프로펠러
   - CCW 모터 → CCW 프로펠러
```

---

## 프로펠러 방향 실수

```
┌────────────────────────────────────┐
│ ❌ 흔한 실수                        │
├────────────────────────────────────┤
│ CW 모터에 CCW 프로펠러 장착         │
│                                    │
│ 결과:                              │
│ - 추력 50% 감소                    │
│ - 진동 발생                        │
│ - 불안정한 비행                    │
│ - 이륙 불가능                      │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ ✓ 올바른 장착                       │
├────────────────────────────────────┤
│ 프로펠러 각인 확인:                 │
│ - "CW" 또는 "R" 표시               │
│ - "CCW" 또는 "L" 표시              │
│                                    │
│ 모터 회전 방향과 일치시킴           │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"모터 넘버링과 회전 방향은 표준화되어 있습니다. X-프레임의 경우 전방 우측이 M1이고, 시계방향 순서로 M1, M4, M2, M3입니다.

회전 방향은 대각선 모터 쌍이 같은 방향입니다. M1과 M4는 시계방향, M2와 M3는 반시계방향으로 회전합니다.

이렇게 대칭적으로 반대로 회전하는 이유는 뉴턴의 제3법칙 때문입니다. 모터가 프로펠러를 시계방향으로 회전시키면, 반작용으로 드론 본체가 반시계방향으로 회전하려 합니다. 대각선 쌍을 같은 방향으로 회전시키면 이 반작용 토크가 상쇄됩니다.

실제 드론 조립 시 가장 흔한 실수는 프로펠러 방향을 잘못 장착하는 것입니다. CW 모터에 CCW 프로펠러를 장착하면 추력이 50% 감소하고 진동이 발생하여 이륙조차 불가능합니다. 반드시 프로펠러의 CW/CCW 각인을 확인하고 모터 회전 방향과 일치시켜야 합니다."

---
---

# 슬라이드 28: ESC와 PWM 신호

## 제목
**ESC (전자 속도 제어기) 통신**

## 부제목
PWM, DShot, CAN 프로토콜

---

## 왼쪽: PWM 신호 기초

### 펄스 폭 변조 (PWM)

```
신호 예시:

1000 μs (최소):
┌┐
│└─────────────────────────
0    1ms         20ms

1500 μs (중간):
┌───┐
│   └─────────────────────
0    1.5ms       20ms

2000 μs (최대):
┌──────┐
│      └──────────────────
0    2ms         20ms

주기: 20ms (50Hz)
범위: 1000~2000 μs
```

---

## 중단: PWM 코드

```cpp
// PX4 PWM 출력 함수
int pwm_main_ioctl(
    unsigned int cmd,
    unsigned long arg
)
{
    switch (cmd) {
        case PWM_SERVO_SET(channel):
        {
            // 📖 예시:
            // channel = 0 (M1)
            // arg = 1500 (μs)
            
            // 하드웨어 타이머 설정
            up_pwm_servo_set(channel, arg);
            
            // 🔍 의미:
            // 타이머 레지스터에
            // 1500 μs 펄스 폭 설정
            
            break;
        }
        
        case PWM_SERVO_GET(channel):
        {
            // 현재 PWM 값 읽기
            return up_pwm_servo_get(channel);
        }
    }
}

// ESC로 신호 전송
// 물리적으로: 핀 전압 HIGH → LOW
//            1500 μs 후 다시 HIGH
```

---

## 오른쪽 상단: DShot 프로토콜

### 디지털 신호 (DShot)

```
┌────────────────────────────────────┐
│ DShot 장점                          │
├────────────────────────────────────┤
│ ✓ 디지털 신호 (노이즈 없음)         │
│ ✓ CRC 체크섬 (오류 감지)            │
│ ✓ 양방향 통신 가능                  │
│ ✓ 텔레메트리 (RPM, 전류)            │
│ ✓ 낮은 지연시간                     │
└────────────────────────────────────┘

DShot 버전:
- DShot150: 150 kbit/s
- DShot300: 300 kbit/s (일반)
- DShot600: 600 kbit/s
- DShot1200: 1200 kbit/s (고성능)
```

### DShot 프레임

```
16비트 프레임:
┌─────┬─────┬────┐
│11bit│1bit │4bit│
│값   │텔레 │CRC │
└─────┴─────┴────┘

예시: 50% 스로틀
값: 1024 (0~2047 범위의 50%)
텔레메트리: 1 (요청)
CRC: 계산된 체크섬

전송: 비트별로 HIGH/LOW 펄스
```

---

## 오른쪽 하단: CAN 버스

### UAVCAN / DroneCAN

```
┌────────────────────────────────────┐
│ CAN 버스 장점                       │
├────────────────────────────────────┤
│ ✓ 다중 기기 (최대 127개)            │
│ ✓ 긴 케이블 (최대 40m)              │
│ ✓ 오류 감지 및 재전송               │
│ ✓ 표준화된 메시지                   │
│ ✓ 플러그 앤 플레이                  │
└────────────────────────────────────┘

연결 예시:
┌────────┐      CAN H
│Pixhawk │───────┬──────┬──────
│        │       │      │
└────────┘    ┌──┴─┐ ┌──┴─┐
              │ESC1│ │ESC2│
              └────┘ └────┘
        CAN L
───────┴──────┴──────
```

---

## 하단: 프로토콜 비교

| 항목 | PWM | DShot | CAN |
|------|-----|-------|-----|
| **신호 타입** | 아날로그 | 디지털 | 디지털 |
| **배선** | 1선/모터 | 1선/모터 | 버스 |
| **지연시간** | 2-4 ms | 1-2 ms | 2-3 ms |
| **양방향** | ✗ | ✓ | ✓ |
| **텔레메트리** | ✗ | ✓ | ✓ |
| **비용** | 낮음 | 중간 | 높음 |
| **사용처** | 입문 | 레이싱 | 산업용 |

---

## 발표 스크립트

"모터 믹싱의 최종 출력은 ESC(전자 속도 제어기)에게 전달됩니다. 전통적으로 PWM 신호를 사용해왔습니다.

PWM은 펄스 폭으로 속도를 제어합니다. 1000 마이크로초는 최소, 2000 마이크로초는 최대입니다. 20밀리초마다 펄스를 보내므로 50Hz 주파수입니다.

최근에는 DShot이라는 디지털 프로토콜이 인기입니다. 디지털이라 노이즈가 없고, CRC 체크섬으로 오류를 감지하며, 양방향 통신으로 RPM과 전류 같은 텔레메트리를 받을 수 있습니다.

산업용이나 대형 드론에서는 CAN 버스를 사용합니다. 하나의 버스에 최대 127개 기기를 연결할 수 있고, 40m까지 긴 케이블도 가능하며, 오류 감지 및 재전송 기능이 있습니다.

PWM은 비용이 낮아 입문용에 적합하고, DShot은 레이싱 드론에, CAN은 산업용 드론에 주로 사용됩니다."

---
---

# 슬라이드 29: 안전 기능

## 제목
**모터 믹싱의 안전 기능**

## 부제목
Arming, Fail-safe, 과전류 보호

---

## 왼쪽: Arming 시스템

### Arming/Disarming

```cpp
bool AP_Arming::arm(bool check)
{
    // ═══════════════════════════════════
    // 안전 체크 (Arming 전)
    // ═══════════════════════════════════
    
    // 1. RC 신호 확인
    if (!rc_calibration_checks()) {
        return false;  // "RC not calibrated"
    }
    
    // 2. 센서 상태 확인
    if (!ins_checks()) {
        return false;  // "IMU not healthy"
    }
    
    // 3. GPS 확인 (GPS 모드일 때)
    if (requires_gps && !gps_checks()) {
        return false;  // "GPS not ready"
    }
    
    // 4. 배터리 확인
    if (!battery_checks()) {
        return false;  // "Battery too low"
    }
    
    // 5. 지면 확인 (가속도계)
    if (!is_on_ground()) {
        return false;  // "Not on ground"
    }
    
    // 모든 체크 통과
    _armed = true;
    motors.armed(true);  // 모터 활성화
    
    return true;
}
```

---

## 중단: Fail-safe 시스템

### RC 신호 손실

```cpp
void Copter::failsafe_radio_on_event()
{
    // RC 신호 1초 이상 손실
    
    if (motors.armed()) {
        // 비행 중이면
        
        switch (g.failsafe_radio) {
            case FS_RADIO_RTL:
                // Return To Launch
                set_mode(RTL);
                break;
            
            case FS_RADIO_LAND:
                // 즉시 착륙
                set_mode(LAND);
                break;
            
            case FS_RADIO_BRAKE:
                // 제자리 정지
                set_mode(BRAKE);
                break;
        }
    }
}
```

### 배터리 부족

```cpp
void Copter::failsafe_battery_event()
{
    // 배터리 10% 미만
    
    if (battery.capacity_remaining_pct() < 10) {
        // 강제 착륙 모드
        set_mode(LAND);
        
        // 모터 출력 제한
        motors.set_throttle_limit(0.7f);
    }
    
    // 배터리 5% 미만
    if (battery.capacity_remaining_pct() < 5) {
        // 긴급 하강
        motors.set_throttle_limit(0.5f);
    }
}
```

---

## 오른쪽: 모터 보호 기능

### 과전류 보호

```cpp
void AP_MotorsMatrix::output_armed()
{
    for (int i = 0; i < 4; i++) {
        // 전류 모니터링
        float current = _battery.current_amps();
        
        if (current > MAX_CURRENT) {
            // 과전류 감지
            
            // 모든 모터 출력 감소
            for (int j = 0; j < 4; j++) {
                _thrust_rpyt_out[j] *= 0.9f;
            }
            
            // 경고 로그
            gcs().send_text(
                MAV_SEVERITY_WARNING,
                "Motor overcurrent: %.1f A",
                current
            );
        }
    }
}
```

### 온도 보호

```cpp
void ESC::check_temperature()
{
    float temp = read_temperature();
    
    if (temp > 80.0f) {
        // 80°C 초과: 경고
        send_warning("ESC temp high");
    }
    
    if (temp > 90.0f) {
        // 90°C 초과: 출력 감소
        set_throttle_limit(0.7f);
    }
    
    if (temp > 100.0f) {
        // 100°C 초과: 긴급 정지
        emergency_stop();
    }
}
```

---

## 하단: 안전 체크리스트

```
✓ 비행 전 체크 (Pre-flight)
  ☑ RC 캘리브레이션
  ☑ 센서 상태 (IMU, GPS, 기압계)
  ☑ 배터리 전압 (11.1V 이상)
  ☑ 프로펠러 방향 및 고정
  ☑ 모터 회전 방향
  ☑ Fail-safe 설정

✓ 비행 중 모니터링
  ☑ RC 신호 강도
  ☑ 배터리 잔량
  ☑ ESC 온도
  ☑ 모터 전류
  ☑ GPS 위성 수

✓ 비행 후 점검
  ☑ 로그 파일 분석
  ☑ 배터리 전압 측정
  ☑ 모터/ESC 온도 확인
  ☑ 프로펠러 손상 검사
```

---

## 발표 스크립트

"모터 믹싱에는 여러 안전 기능이 내장되어 있습니다.

먼저 Arming 시스템입니다. 모터가 작동하려면 반드시 Arming 상태여야 합니다. Arming 전에 RC 캘리브레이션, 센서 상태, GPS, 배터리, 지면 확인 등 5가지 체크를 수행합니다. 하나라도 실패하면 모터가 작동하지 않습니다.

Fail-safe 시스템도 중요합니다. RC 신호가 1초 이상 손실되면 자동으로 RTL(귀환) 모드나 LAND(착륙) 모드로 전환됩니다. 배터리가 10% 미만이면 강제 착륙하고, 5% 미만이면 긴급 하강합니다.

과전류 보호 기능도 있습니다. 전류가 최대치를 초과하면 모든 모터 출력을 90%로 감소시켜 ESC를 보호합니다. ESC 온도가 80도를 초과하면 경고를 보내고, 100도를 초과하면 긴급 정지합니다.

비행 전에는 반드시 체크리스트를 확인해야 합니다."

---
---

# 슬라이드 30: 다양한 기체 타입

## 제목
**다양한 기체의 모터 믹싱**

## 부제목
Hexa, Octo, Coax, Y6

---

## 헥사콥터 (6개 모터)

### 배치

```
        M1
         │
    M6  / \  M2
       /   \
      /     \
    M5       M3
      \     /
       \   /
        \ /
        M4

믹싱 행렬 (6×4):
┌───┐   ┌                        ┐ ┌───┐
│M1 │   │ +1  -0.5  -1.0  +1.0   │ │ T │
│M2 │   │ +1  -0.5  +1.0  -1.0   │ │ R │
│M3 │ = │ +1  +1.0  +0.0  +1.0   │ │ P │
│M4 │   │ +1  +0.5  +1.0  -1.0   │ │ Y │
│M5 │   │ +1  +1.0  +0.0  +1.0   │ └───┘
│M6 │   │ +1  +0.5  -1.0  -1.0   │
└───┘   └                        ┘
```

**장점:**
- 모터 1개 고장 시에도 비행 가능
- 더 큰 페이로드
- 안정성 향상

---

## 옥타콥터 (8개 모터)

### X8 구성 (Coaxial)

```
    M3/M7     M1/M5
       ╲       ╱
        ╲     ╱
         ╲   ╱
          ╲ ╱
           X
          ╱ ╲
         ╱   ╲
        ╱     ╲
       ╱       ╲
    M2/M6     M4/M8

상하 배치:
- 위쪽: M1, M2, M3, M4
- 아래쪽: M5, M6, M7, M8
- 대각선 반대 회전
```

**장점:**
- 높은 추력 (20kg+ 페이로드)
- 높은 중복성
- 영화 촬영용

**단점:**
- 높은 비용
- 복잡한 배선
- 큰 크기

---

## Y6 구성

### 배치

```
        M1
        M2 (동축)
       ╱
      ╱
     ╱
    O (중심)
     ╲     ╲
      ╲     ╲
       ╲     ╲
      M5    M3
      M6    M4
    (동축)  (동축)

3개 암, 각 암에 2개 모터
```

**특징:**
- 컴팩트한 크기
- 헥사 수준의 추력
- 쿼드보다 안정적

---

## 믹싱 행렬 비교

### 쿼드 vs 헥사 vs 옥타

```
┌──────────────────────────────────────┐
│ 쿼드 (4×4)                            │
├──────────────────────────────────────┤
│ • 가장 간단                           │
│ • 4개 독립 변수 = 4개 자유도          │
│ • 단일 고장 시 추락                   │
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│ 헥사 (6×4)                            │
├──────────────────────────────────────┤
│ • 과결정 시스템 (6 > 4)               │
│ • 무수히 많은 해 존재                 │
│ • 최적화: 에너지 최소화               │
│ • 단일 고장 시 비행 가능              │
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│ 옥타 (8×4)                            │
├──────────────────────────────────────┤
│ • 최고 중복성                         │
│ • 2개 고장까지 비행 가능              │
│ • 복잡한 최적화                       │
└──────────────────────────────────────┘
```

---

## 하단: 실제 사용 사례

```
┌────────────────────────────────────┐
│ 쿼드콥터                            │
├────────────────────────────────────┤
│ • 취미용                            │
│ • 레이싱                            │
│ • 가벼운 촬영 (< 2kg)               │
│                                    │
│ 예시: DJI Mini, FPV 레이싱          │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 헥사콥터                            │
├────────────────────────────────────┤
│ • 전문 촬영 (2-5kg)                 │
│ • 산업 점검                         │
│ • 중형 배송                         │
│                                    │
│ 예시: DJI S900, Freefly Alta        │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 옥타콥터                            │
├────────────────────────────────────┤
│ • 영화 촬영 (5-20kg)                │
│ • 대형 배송                         │
│ • 고가 페이로드                     │
│                                    │
│ 예시: Freefly Alta X, DJI S1000     │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"쿼드콥터 외에도 다양한 기체가 있습니다.

헥사콥터는 6개 모터를 사용하며, 믹싱 행렬은 6×4입니다. 4개 입력을 6개 출력으로 변환하는 과결정 시스템이죠. 장점은 모터 1개가 고장 나도 비행할 수 있다는 점입니다. 에너지 최소화 같은 최적화 기준으로 해를 구합니다.

옥타콥터는 8개 모터로 최고 중복성을 제공합니다. X8 구성에서는 각 암에 2개 모터를 상하로 배치합니다. 20kg 이상의 무거운 페이로드를 들 수 있어 영화 촬영용으로 사용됩니다.

Y6는 3개 암에 각각 2개씩 동축 모터를 배치한 구성입니다. 크기는 작지만 헥사 수준의 추력을 냅니다.

실제 사용 사례를 보면, 쿼드는 취미와 레이싱, 헥사는 전문 촬영과 산업 점검, 옥타는 영화 촬영과 대형 배송에 사용됩니다."

---
---

# 슬라이드 31: 요약 및 실습 과제

## 제목
**모터 믹싱 요약 및 실습**

## 부제목
이론에서 실전으로

---

## 핵심 요약

### 3단계 변환 과정

```
PID 출력        믹싱 행렬       PWM 변환
(추상적)    →   (정규화)    →   (물리적)

Roll:  0.3      M1: 0.111       1111 μs
Pitch: 0.5      M2: 1.000       2000 μs
Yaw:   0.1  →   M3: 0.667   →   1667 μs
Thrust:0.6      M4: 0.000       1000 μs
```

### 핵심 원리

```
✓ 믹싱 행렬: 4×4 선형 변환
✓ 정규화: 음수 제거 + 스케일링
✓ 비율 유지: 제어 특성 보존
✓ 안전 기능: Arming, Fail-safe
```

---

## 실습 과제 1: 믹싱 계산기

```
┌────────────────────────────────────┐
│ 목표: 수동으로 믹싱 계산            │
├────────────────────────────────────┤
│ 1. Excel/Python 스프레드시트 생성   │
│                                    │
│ 2. 4×4 믹싱 행렬 입력               │
│                                    │
│ 3. 입력값 변경하며 출력 관찰        │
│    - Roll: -1.0 ~ +1.0             │
│    - Pitch: -1.0 ~ +1.0            │
│    - Yaw: -1.0 ~ +1.0              │
│    - Thrust: 0.0 ~ 1.0             │
│                                    │
│ 4. 정규화 알고리즘 구현             │
│    - 음수 제거                     │
│    - 스케일 다운                   │
│                                    │
│ 5. 그래프로 시각화                 │
│    - 4개 모터 출력 막대 그래프      │
└────────────────────────────────────┘

예상 시간: 1~2시간
난이도: ★★☆☆☆
```

---

## 실습 과제 2: SITL 모터 테스트

```
┌────────────────────────────────────┐
│ 목표: 실제 믹싱 동작 관찰           │
├────────────────────────────────────┤
│ 1. PX4 SITL 실행                    │
│                                    │
│ 2. QGroundControl 연결              │
│                                    │
│ 3. 모터 테스트 수행                 │
│    pxh> motor_test test -m 1 -p 50 │
│    → M1이 50% 출력으로 회전         │
│                                    │
│ 4. 각 모터 순차 테스트              │
│    → 위치와 회전 방향 확인          │
│                                    │
│ 5. 수동 비행 모드 (Stabilized)      │
│    → RC 스틱 움직이며 모터 관찰     │
│    → Roll 우측: M2,M3 증가          │
│    → Pitch 전방: M2,M4 증가         │
│                                    │
│ 6. 로그 분석                        │
│    → actuator_outputs 토픽 확인     │
│    → 각 모터 PWM 값 그래프          │
└────────────────────────────────────┘

예상 시간: 2~3시간
난이도: ★★★☆☆
```

---

## 실습 과제 3: 코드 분석 및 수정

```
┌────────────────────────────────────┐
│ 목표: 실제 코드 이해 및 수정        │
├────────────────────────────────────┤
│ 1. ArduPilot 소스 다운로드          │
│                                    │
│ 2. AP_MotorsMatrix.cpp 열기         │
│    위치: libraries/AP_Motors/      │
│                                    │
│ 3. output_armed_stabilizing() 분석  │
│    - 각 줄 주석 달기                │
│    - 믹싱 행렬 찾기                 │
│    - 정규화 코드 찾기               │
│                                    │
│ 4. 커스텀 믹싱 행렬 작성            │
│    - +-프레임으로 변경              │
│    - 또는 헥사콥터 행렬             │
│                                    │
│ 5. 컴파일 및 SITL 테스트            │
│    - make px4_sitl gazebo          │
│    - 변경 사항 확인                 │
└────────────────────────────────────┘

예상 시간: 3~4시간
난이도: ★★★★☆
```

---

## 실습 환경

### Python 믹싱 시뮬레이터 (추천)

```python
import numpy as np

# 믹싱 행렬 (X-프레임)
M = np.array([
    [1, -1, -1,  1],  # M1
    [1,  1,  1, -1],  # M2
    [1,  1, -1,  1],  # M3
    [1, -1,  1, -1]   # M4
])

# 입력
thrust = 0.6
roll = 0.3
pitch = 0.5
yaw = 0.1

inputs = np.array([thrust, roll, pitch, yaw])

# 믹싱
outputs = M @ inputs

print("모터 출력:")
for i, out in enumerate(outputs):
    print(f"M{i+1}: {out:.3f}")

# 정규화
# (여기서 직접 구현해보세요!)
```

---

## 추가 학습 자료

```
📚 공식 문서
- PX4 Mixer: https://docs.px4.io/main/en/concept/mixing.html
- ArduPilot Motors: https://ardupilot.org/copter/docs/motor-thrust-scaling.html

📹 동영상
- Motor Mixing Explained
- ESC Calibration Tutorial

📖 논문
- "Quadrotor Control: Modeling and Control" (Beard, McLain)
- "Motor Mixing and Thrust Allocation for Multirotor UAVs"

💻 코드 저장소
- PX4 Mixer: src/modules/mavlink/streams/mixer.cpp
- ArduPilot: libraries/AP_Motors/AP_MotorsMatrix.cpp
```

---

## 다음 주 예고

```
┌────────────────────────────────────┐
│ 4주차: 센서 융합 (EKF)              │
├────────────────────────────────────┤
│ • 센서 종류 및 특성                 │
│ • 칼만 필터 기초                    │
│ • EKF 알고리즘                      │
│ • 24-상태 추정기                    │
│ • 센서 보정 및 튜닝                 │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"모터 믹싱을 정리하겠습니다. 핵심은 PID 출력을 믹싱 행렬로 변환하고, 정규화하여 PWM 신호로 만드는 3단계 과정입니다.

실습 과제는 3단계입니다. 먼저 Excel이나 Python으로 믹싱 계산기를 만들어 수동으로 계산해봅니다. 그 다음 SITL에서 실제 모터 테스트를 수행하며 동작을 관찰합니다. 마지막으로 실제 소스코드를 분석하고 커스텀 믹싱 행렬을 작성합니다.

Python 믹싱 시뮬레이터 예제 코드도 제공했습니다. 믹싱 행렬과 입력값을 곱하면 각 모터 출력을 계산할 수 있습니다. 정규화 부분은 직접 구현해보는 것이 좋은 연습이 됩니다.

다음 주에는 센서 융합, 특히 EKF 알고리즘을 배웁니다. 센서 데이터를 어떻게 합쳐서 정확한 상태를 추정하는지 알아보겠습니다."

---
---

# 🎓 부록: 발표 팁

## 시간 배분 (50분 기준)

```
슬라이드 21-23: 개요 및 원리 (10분)
슬라이드 24-25: 코드 구현 (15분)
슬라이드 26-28: 실전 및 프로토콜 (15분)
슬라이드 29-31: 안전 & 실습 (10분)
```

## 강조 포인트

```
1. PID와의 연결 강조
   - "지난 시간 PID가 Roll 0.3을 출력했다면..."
   - 전체 흐름의 연속성

2. 물리적 직관 제공
   - "우측으로 기울이려면 좌측 모터가 더 세야 함"
   - 추상적 수식보다 물리 먼저

3. 실수 사례 공유
   - 프로펠러 방향 잘못
   - 모터 순서 혼동
   - 실제 경험 중심
```

## 데모 제안

```
라이브 데모 (시간 허락 시):
1. Python 믹싱 계산기 실행
   - 입력값 변경하며 출력 관찰
2. SITL 모터 테스트
   - 각 모터 순차 동작
3. 로그 파일 분석
   - 실제 PWM 값 그래프
```

---

**성공적인 강의 되시길 바랍니다! 🚁**
