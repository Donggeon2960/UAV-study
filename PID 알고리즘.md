# UAV 3주차 PPT - PID 알고리즘 섹션 완전판

각 슬라이드를 그대로 복사해서 사용하세요.

---

# 슬라이드 9: 계층적 PID 제어 - 전체 구조

## 제목
**알고리즘 1: 계층적 PID 제어**

## 부제목
4단계 구조로 드론을 제어합니다

---

## 왼쪽 영역: 계층 다이어그램

```
명령: "3m 전진하라"
         ↓
┌─────────────────────────────────────┐
│ Level 4: 위치 제어 @ 50Hz            │
│                                     │
│ 입력: 목표 위치 (3m, 0, -5m)         │
│ 출력: 목표 속도 (0.8 m/s)            │
│                                     │
│ 코드: src/modules/mc_pos_control    │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Level 3: 속도 제어 @ 50Hz            │
│                                     │
│ 입력: 목표 속도 (0.8 m/s)            │
│ 출력: 목표 자세 (Pitch 8°)           │
│                                     │
│ 코드: src/modules/mc_pos_control    │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Level 2: 자세 제어 @ 250Hz           │
│                                     │
│ 입력: 목표 자세 (8°)                 │
│ 출력: 목표 각속도 (52 deg/s)         │
│                                     │
│ 코드: src/modules/mc_att_control    │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Level 1: 각속도 제어 @ 1000Hz        │
│                                     │
│ 입력: 목표 각속도 (52 deg/s)         │
│ 출력: 모터 토크 (0.65 Nm)            │
│                                     │
│ 코드: src/modules/mc_rate_control   │
└─────────────────────────────────────┘
         ↓
    [모터 믹싱]
         ↓
  M1  M2  M3  M4
```

## 오른쪽 영역: 핵심 규칙

### 📌 3가지 핵심 원칙

**1. 계층 독립성**
- 각 레벨은 독립적으로 동작
- 상위 출력 = 하위 목표값

**2. 주파수 분리**
- 안쪽 루프가 5~10배 빠름
- Level 1 (1000Hz) → Level 4 (50Hz)

**3. 튜닝 순서**
- 반드시 안쪽부터: Level 1 → Level 4

---

## 하단: 주의사항 박스

```
⚠️ 개발 방법 (튜닝)

PID 튜닝은 반드시 가장 안쪽 루프(Level 1: 각속도)에서 시작하여 
바깥쪽 루프(Level 4: 위치) 순서로 진행해야 합니다.

이유: 하위 루프가 불안정하면 상위 루프도 불안정
```

---

## 발표 스크립트

"드론의 PID 제어는 4단계 계층으로 나뉩니다. 사용자가 '3m 전진하라'는 명령을 내리면, 위치 제어기가 이를 속도 명령으로 변환하고, 속도 제어기는 자세 명령으로, 자세 제어기는 각속도 명령으로, 최종적으로 각속도 제어기가 모터 토크를 계산합니다.

중요한 것은 각 레벨이 독립적으로 동작하며, 안쪽 루프일수록 더 빠른 주파수로 실행된다는 점입니다. 이는 시스템 안정성을 위한 필수 조건입니다."

---

## 이미지/다이어그램 추천

1. **흐름도**: 4단계 계층을 화살표로 연결한 블록 다이어그램
2. **주파수 비교**: 각 레벨의 실행 주파수를 막대 그래프로 표시
3. **데이터 흐름**: 실제 숫자 예시가 포함된 애니메이션

---
---

# 슬라이드 10: Level 1 - 각속도 제어기 (Part 1)

## 제목
**Level 1: 각속도 제어 - 완전한 코드 (1/2)**

## 부제목
가장 안쪽 루프, 드론의 "반사신경"

---

## 상단: 역할 설명 박스

```
┌──────────────────────────────────────────────┐
│ 역할: 목표 각속도를 추종하기 위한 토크 계산    │
│ 주파수: 250-1000 Hz (일반적으로 400Hz)        │
│ 위치: PX4-Autopilot/src/lib/rate_control/   │
│       RateControl.cpp                        │
└──────────────────────────────────────────────┘
```

---

## 중단: 코드 Part 1 (Step 1-3)

```cpp
float RateControl::update(float rate_sp, float rate, 
                          float dt, float limit)
{
    // ═══════════════════════════════════════════════
    // Step 1: 오차 계산
    // ═══════════════════════════════════════════════
    float error = rate_sp - rate;
    
    // 📖 예시:
    // rate_sp = 52 deg/s (목표 각속도)
    // rate = 48 deg/s (현재 각속도, 자이로 측정)
    // error = 4 deg/s
    
    
    // ═══════════════════════════════════════════════
    // Step 2: P항 (비례) - "즉각 반응"
    // ═══════════════════════════════════════════════
    float proportional = _kp * error;  
    // _kp = 0.15 (게인)
    
    // 📖 예시:
    // proportional = 0.15 × 4 = 0.6
    
    // 🔍 의미:
    // 오차가 클수록 강한 토크를 생성
    // "스프링처럼" 목표를 향해 당김
    
    
    // ═══════════════════════════════════════════════
    // Step 3: I항 (적분) - "누적 오차 제거"
    // ═══════════════════════════════════════════════
    _integral += error * dt;
    
    // 적분 와인드업 방지 (과도한 누적 방지)
    _integral = constrain(_integral, -0.4f, 0.4f);
    
    float integral = _ki * _integral;
    // _ki = 0.05
    
    // 📖 예시:
    // 이전 누적: _integral = 0.3
    // 새 누적: _integral = 0.3 + (4 × 0.001) = 0.304
    // integral = 0.05 × 0.304 = 0.0152
    
    // 🔍 의미:
    // 작은 오차가 계속되면 서서히 힘을 증가
    // 정상상태 오차(steady-state error) 완전 제거
```

---

## 하단: P항과 I항의 역할

### P항 (비례)
```
P = Kp × error

역할: 스프링
- 오차 크면 → 강하게
- 오차 작으면 → 약하게

특성:
✓ 빠른 응답
✗ 정상상태 오차 발생
✗ 게인 너무 크면 진동
```

### I항 (적분)
```
I = Ki × ∫error dt

역할: 기억
- 작은 오차 계속 → 점점 증가

특성:
✓ 정상상태 오차 제거
✗ 오버슈트 가능
✗ 느린 응답
```

---

## 발표 스크립트

"Level 1 각속도 제어기는 가장 안쪽 루프로, 400Hz~1000Hz의 매우 빠른 속도로 실행됩니다. 코드를 단계별로 보시면, 먼저 목표 각속도와 현재 각속도의 오차를 계산합니다.

P항은 이 오차에 비례하여 즉각 반응합니다. 마치 스프링처럼 오차가 크면 강하게 당기는 것이죠. 

I항은 작은 오차가 계속 누적되는 것을 감지하여, 정상상태 오차를 완전히 제거합니다. 다만 과도하게 누적되면 오버슈트가 발생하므로, constrain 함수로 ±0.4 범위로 제한합니다."

---
---

# 슬라이드 11: Level 1 - 각속도 제어기 (Part 2)

## 제목
**Level 1: 각속도 제어 - 완전한 코드 (2/2)**

## 부제목
D항 계산 및 최종 출력

---

## 상단: 코드 Part 2 (Step 4-6)

```cpp
    // ═══════════════════════════════════════════════
    // Step 4: D항 (미분) - "오버슈트 방지"
    // ═══════════════════════════════════════════════
    float derivative_raw = (error - _last_error) / dt;
    
    // 저역 통과 필터 (노이즈 제거)
    // 이유: 센서 노이즈로 미분값이 튀는 것 방지
    float alpha = 0.3f;  // 필터 계수
    float derivative_filtered = alpha * derivative_raw 
                              + (1 - alpha) * _last_derivative;
    
    float derivative = _kd * derivative_filtered;
    // _kd = 0.003
    
    // 📖 예시:
    // _last_error = 3.5 deg/s
    // error = 4 deg/s
    // derivative_raw = (4 - 3.5) / 0.001 = 500 deg/s²
    // 필터링: 0.3×500 + 0.7×480 = 486 deg/s²
    // derivative = 0.003 × 486 = 1.458
    
    // 상태 저장
    _last_error = error;
    _last_derivative = derivative_filtered;
    
    // 🔍 의미:
    // 오차가 급격히 변하면 제동력 제공
    // "댐퍼처럼" 오버슈트 방지
    
    
    // ═══════════════════════════════════════════════
    // Step 5: PID 출력 합산
    // ═══════════════════════════════════════════════
    float output = proportional + integral + derivative;
    
    // 📖 예시:
    // output = 0.6 + 0.0152 + 1.458 = 2.073
    
    
    // ═══════════════════════════════════════════════
    // Step 6: 출력 제한 (Saturation)
    // ═══════════════════════════════════════════════
    output = constrain(output, -limit, limit);
    
    // 📖 예시:
    // limit = 1.0
    // output = constrain(2.073, -1.0, 1.0) = 1.0
    
    // 🔍 의미:
    // 물리적 한계를 넘는 출력 방지
    // 모터가 낼 수 있는 최대 토크 제한
    
    return output;  // 최종 토크 명령 반환
}
```

---

## 하단 왼쪽: D항의 역할

```
D = Kd × d(error)/dt

역할: 댐퍼 (감쇠기)
- 오차 급변 → 제동
- 목표 근접 → 속도 줄임

특성:
✓ 오버슈트 방지
✓ 안정성 향상
✗ 노이즈에 민감
  (필터 필수!)
```

---

## 하단 오른쪽: 기본 게인 값

```
┌─────────────────────────┐
│ Pixhawk 기본 게인        │
├─────────────────────────┤
│ Kp = 0.15               │
│ Ki = 0.05               │
│ Kd = 0.003              │
├─────────────────────────┤
│ 적분 제한 = ±0.4        │
│ 출력 제한 = ±1.0        │
└─────────────────────────┘

이 값들은 기체마다 다름!
튜닝 필수
```

---

## 발표 스크립트

"D항은 오차의 변화율, 즉 미분을 계산합니다. 오차가 급격히 변할 때 제동력을 제공하여 오버슈트를 방지하는 댐퍼 역할을 합니다.

다만 센서 노이즈 때문에 미분값이 심하게 튀므로, 저역 통과 필터를 적용합니다. 필터 계수 alpha=0.3은 30%는 새 값, 70%는 이전 값을 사용한다는 의미입니다.

최종적으로 P, I, D 세 항을 합산하고, constrain 함수로 ±1.0 범위로 제한합니다. 예시에서 2.073이 계산되었지만, 물리적으로 모터가 낼 수 있는 최대값은 1.0이므로 제한합니다."

---
---

# 슬라이드 12: PID 각 항의 물리적 의미

## 제목
**PID 각 항의 역할: 스프링-댐퍼 시스템**

## 부제목
왜 P, I, D가 필요한가?

---

## 왼쪽 영역: 각 항의 비유

### P항 (비례) = 스프링

```
     목표
      ↓
   ╱╲╱╲╱╲
  ╱      ╲ → [드론]
 ╱        ╲

오차가 크면 → 강하게 당김
오차가 작으면 → 약하게 당김

문제점:
- 진동 발생
- 정상상태 오차 남음
```

### I항 (적분) = 기억

```
시간 →
오차 ████████ (누적)
     ↓
   서서히
   힘 증가

작은 오차가 계속되면
→ 점점 힘을 증가

장점:
- 정상상태 오차 완전 제거
```

### D항 (미분) = 댐퍼

```
    │
 ───┴─── [유압 실린더]

급격한 변화 감지
→ 제동력 제공

장점:
- 오버슈트 방지
- 안정성 향상
```

---

## 오른쪽 영역: 응답 그래프 비교

### P만 사용
```
목표 ─────────────
     ╱╲╱╲╱╲╱╲╱╲
    ╱          
   ╱           

✗ 계속 진동
✗ 정상상태 오차
```

### P + I 사용
```
목표 ─────────────
     ╱╲╱╲      
    ╱    ╲     
   ╱      ╲    
  ╱        ────

✓ 정상상태 오차 없음
△ 진동은 여전히 있음
```

### P + I + D 사용 (완전체)
```
목표 ─────────────
     ╱         
    ╱──────────
   ╱           

✓ 부드럽게 도달
✓ 오버슈트 없음
✓ 안정적
```

---

## 하단: 각 게인의 효과 요약표

| 게인 증가 | 장점 | 단점 | 조정 팁 |
|----------|------|------|---------|
| **Kp ↑** | 빠른 응답 | 진동 발생 | 진동 시작까지 올리고 약간 낮춤 |
| **Ki ↑** | 정상상태 오차 제거 | 오버슈트 증가 | P 튜닝 후 천천히 증가 |
| **Kd ↑** | 오버슈트 감소 | 노이즈 증폭 | P/I 튜닝 후 조금씩 증가 |

---

## 발표 스크립트

"PID 각 항을 물리적으로 이해해봅시다. P항은 스프링처럼 작동합니다. 오차가 크면 강하게 당기지만, 이것만으로는 진동이 발생하고 정상상태 오차가 남습니다.

I항은 기억 장치입니다. 작은 오차가 계속 누적되는 것을 감지하여 서서히 힘을 증가시킵니다. 이를 통해 정상상태 오차를 완전히 제거할 수 있습니다.

D항은 댐퍼, 즉 감쇠기입니다. 오차가 급격히 변하는 것을 감지하면 제동력을 제공하여 오버슈트를 방지합니다.

그래프를 보시면, P만 사용하면 계속 진동하고, P+I를 사용하면 진동은 줄지만 여전히 불안정합니다. P+I+D를 모두 사용해야 부드럽고 안정적으로 목표에 도달합니다."

---
---

# 슬라이드 13: 실전 예시 - 바람이 불 때

## 제목
**실전 시나리오: 바람 대응**

## 부제목
호버링 중 갑자기 바람이 불면?

---

## 시나리오 타임라인

### t = 0.000s: 정상 호버링

```
┌──────────────────────────────────────┐
│ 상태: 안정적 호버링                   │
├──────────────────────────────────────┤
│ 목표 각속도: 0 deg/s                  │
│ 현재 각속도: 0 deg/s                  │
│ 오차: 0                              │
│                                      │
│ P항: 0                               │
│ I항: 0                               │
│ D항: 0                               │
│                                      │
│ 출력: 0                              │
│                                      │
│ 💡 변화 없음, 정지 유지               │
└──────────────────────────────────────┘
```

⬇️ **갑자기 바람이 분다!** ⬇️

---

### t = 0.100s: 바람 시작 (초기 반응)

```
┌──────────────────────────────────────┐
│ 상태: 바람에 밀려 회전 중              │
├──────────────────────────────────────┤
│ 목표 각속도: 0 deg/s                  │
│ 현재 각속도: -15 deg/s (바람에 밀림)   │
│ 오차: 15 deg/s ← 큰 오차!            │
│                                      │
│ P항: 0.15 × 15 = 2.25                │
│ I항: 0 (아직 누적 없음)               │
│ D항: 0.003 × 15000 = 45 (매우 큼!)   │
│                                      │
│ 합계: 47.25 → 제한 → 1.0 (최대!)     │
│                                      │
│ 💡 급격한 변화 감지!                  │
│    최대 토크로 대응                   │
└──────────────────────────────────────┘
```

**해석:** D항이 급격한 변화를 감지하여 매우 큰 값(45)을 출력. 즉시 최대 토크로 대응

---

### t = 0.200s: 복구 중 (과잉 대응 제동)

```
┌──────────────────────────────────────┐
│ 상태: 약간 회복되었지만 너무 빠름      │
├──────────────────────────────────────┤
│ 목표 각속도: 0 deg/s                  │
│ 현재 각속도: -8 deg/s (회복 중)       │
│ 오차: 8 deg/s                        │
│                                      │
│ P항: 0.15 × 8 = 1.2                  │
│ I항: 0.05 × 0.015 = 0.00075          │
│ D항: 0.003 × -7000 = -21 (음수!)     │
│                                      │
│ 합계: -19.8 → 제한 → -1.0 (반대!)    │
│                                      │
│ 💡 너무 빠르게 돌아가는 중!           │
│    반대 방향 최대 토크로 제동         │
└──────────────────────────────────────┘
```

**해석:** 오차가 감소하는 것을 D항이 감지하여 음수 출력. 과잉 대응 방지

---

### t = 0.500s: 안정화

```
┌──────────────────────────────────────┐
│ 상태: 거의 복구, 미세 조정 중          │
├──────────────────────────────────────┤
│ 목표 각속도: 0 deg/s                  │
│ 현재 각속도: -0.5 deg/s               │
│ 오차: 0.5 deg/s (작음)               │
│                                      │
│ P항: 0.15 × 0.5 = 0.075              │
│ I항: 0.05 × 0.05 = 0.0025            │
│ D항: 0.003 × -500 = -1.5             │
│                                      │
│ 합계: -1.42 → 제한 → -1.0            │
│                                      │
│ 💡 거의 도착, 부드럽게 정착 중         │
└──────────────────────────────────────┘
```

**해석:** 작은 오차에도 I항이 누적되어 정상상태 오차 제거

---

## 하단: 핵심 교훈

```
✅ D항의 중요성
  → 급격한 변화를 즉시 감지
  → 초기 대응 속도를 극대화

✅ I항의 필요성
  → 작은 오차도 완전히 제거
  → 장기적 안정성 확보

✅ 제한(Saturation)의 중요성
  → 물리적 한계 준수
  → 시스템 보호
```

---

## 발표 스크립트

"실제 비행 시나리오를 봅시다. 드론이 안정적으로 호버링하고 있다가 갑자기 바람이 불면 어떻게 될까요?

0.1초 시점에서 바람이 불어 드론이 -15 deg/s로 회전하기 시작합니다. 이때 D항이 급격한 변화를 감지하여 45라는 매우 큰 값을 출력합니다. P항의 2.25와 합쳐져 47.25가 되지만, 제한 함수에 의해 1.0으로 제한되어 최대 토크로 즉시 대응합니다.

0.2초 시점에는 회복 중이지만 너무 빠르게 돌아가고 있습니다. 이번엔 D항이 음수(-21)를 출력하여 과잉 대응을 제동합니다.

0.5초 시점에는 거의 안정화되었지만 -0.5 deg/s의 작은 오차가 남아있습니다. 이때 I항이 누적되어 이 작은 오차까지 완전히 제거합니다.

이것이 PID 3개 항이 모두 필요한 이유입니다."

---
---

# 슬라이드 14: Level 2 - 자세 제어기

## 제목
**Level 2: 자세 제어 - 쿼터니언 기반**

## 부제목
P 제어만으로 충분한 이유

---

## 상단: 역할 설명

```
┌─────────────────────────────────────────────┐
│ 역할: 목표 자세 → 목표 각속도 변환           │
│ 주파수: 250 Hz                               │
│ 특징: P 제어만 사용 (I, D 불필요)            │
│ 위치: src/modules/mc_att_control/           │
│       AttitudeControl/AttitudeControl.cpp   │
└─────────────────────────────────────────────┘
```

---

## 중단: 완전한 코드

```cpp
Vector3f AttitudeControl::update(const Quatf &q_sp, 
                                  const Quatf &q)
{
    // ═══════════════════════════════════════════════
    // Step 1: 쿼터니언 오차 계산
    // ═══════════════════════════════════════════════
    Quatf q_error = q_sp * q.inversed();
    
    // 📖 예시:
    // q_sp = 8도 피치 (목표 자세)
    // q = 0도 (현재 자세)
    // q_error = 8도 차이를 나타내는 쿼터니언
    
    
    // ═══════════════════════════════════════════════
    // Step 2: 회전 벡터로 변환
    // ═══════════════════════════════════════════════
    Vector3f e_R = 2.0f * q_error.imag();  // [qx, qy, qz] × 2
    
    if (q_error.scalar() < 0.0f) {
        e_R = -e_R;  // 최단 경로 회전 보장
    }
    
    // 📖 예시:
    // e_R = [0, 0.14, 0] rad
    //     = [0°, 8°, 0°]
    
    
    // ═══════════════════════════════════════════════
    // Step 3: P 제어 (자세 제어는 P만 사용)
    // ═══════════════════════════════════════════════
    Vector3f rate_sp;
    
    rate_sp(0) = _gain_p(0) * e_R(0);  // Roll
    rate_sp(1) = _gain_p(1) * e_R(1);  // Pitch
    rate_sp(2) = _gain_p(2) * e_R(2);  // Yaw
    
    // 📖 예시:
    // Roll:  6.5 × 0 = 0 rad/s
    // Pitch: 6.5 × 0.14 = 0.91 rad/s = 52 deg/s
    // Yaw:   2.8 × 0 = 0 rad/s
    
    // 🔍 의미:
    // "8도 기울어져 있으니,
    //  초당 52도로 회전해서 바로잡아라"
    
    
    // ═══════════════════════════════════════════════
    // Step 4: 각속도 제한
    // ═══════════════════════════════════════════════
    float max_rate = 3.14f;  // 180 deg/s
    rate_sp = constrain(rate_sp, -max_rate, max_rate);
    
    return rate_sp;  // Level 1 (Rate Controller)로 전달
}
```

---

## 하단 왼쪽: Q&A

```
Q: 왜 자세 제어는 P만 사용하나요?

A: 3가지 이유

1. I항 불필요
   → 정상상태 오차 제거는
     하위 Rate Controller의
     I항이 이미 담당

2. D항 불필요
   → 각도의 변화율 = 각속도
   → 이미 센서로 직접 측정됨
   → 굳이 미분 계산 불필요

3. P만 충분
   → "각도 오차 → 각속도"
     단순 변환만 하면 됨
   → 실제 추종은 Rate Controller가
     PID로 처리
```

---

## 하단 오른쪽: 기본 게인

```
┌──────────────────────┐
│ 자세 제어 P 게인      │
├──────────────────────┤
│ Roll:  6.5           │
│ Pitch: 6.5           │
│ Yaw:   2.8           │
├──────────────────────┤
│ 최대 각속도: 180°/s  │
└──────────────────────┘

Rate 게인(0.15)보다
훨씬 큰 값을 사용!
```

---

## 발표 스크립트

"Level 2 자세 제어기는 쿼터니언을 사용합니다. 쿼터니언은 Gimbal Lock 문제가 없어 모든 자세를 안정적으로 표현할 수 있습니다.

코드를 보시면 놀랍게도 P 제어만 사용합니다. 왜일까요?

첫째, I항은 필요 없습니다. 정상상태 오차 제거는 하위의 Rate Controller가 이미 I항으로 처리하고 있기 때문입니다.

둘째, D항도 필요 없습니다. 각도의 변화율은 바로 각속도인데, 이건 자이로스코프로 직접 측정되고 있습니다. 굳이 미분 계산을 할 이유가 없습니다.

자세 제어기는 단순히 '각도 오차를 각속도 명령으로 변환'하는 역할만 하면 됩니다. 실제 각속도 추종은 Level 1의 Rate Controller가 PID로 완벽하게 처리합니다.

게인을 보시면 6.5로, Rate 게인 0.15보다 훨씬 큽니다. 이는 자세 제어가 더 공격적으로 반응해야 하기 때문입니다."

---
---

# 슬라이드 15: 쿼터니언 vs 오일러각

## 제목
**왜 쿼터니언을 사용하는가?**

## 부제목
Gimbal Lock 문제의 해결

---

## 왼쪽: 오일러각의 문제 (Gimbal Lock)

### 정상 상태
```
         Z (Yaw)
         │
         │
    Y ───┼─── X (Roll)
  (Pitch)│

3개 축이 모두 독립적
→ 3자유도 회전 가능
```

### Gimbal Lock 발생 (Pitch = 90°)

```
    Z,X (겹침!)
      ╱│
     ╱ │
    ╱  │
   Y───┘

Roll 축과 Yaw 축이 겹침!
→ 1자유도 상실
→ 제어 불능
```

### 실제 사례

```
┌─────────────────────────────┐
│ 드론이 90도로 세워지면:       │
├─────────────────────────────┤
│                             │
│     ↑                       │
│     │ 드론                   │
│     │                       │
│     │                       │
│  ───┴───                    │
│                             │
│ 이 상태에서 좌우 회전 불가!   │
│ Roll과 Yaw가 같은 축         │
└─────────────────────────────┘
```

---

## 오른쪽: 쿼터니언의 장점

### 쿼터니언 표현

```
q = [w, x, y, z]  (4개 숫자)

w: 스칼라 부분
x, y, z: 벡터 부분
```

### 장점

```
✓ Gimbal Lock 없음
  → 모든 자세 표현 가능

✓ 연속적인 회전
  → 중간값 보간 쉬움

✓ 적은 연산량
  → 4개 숫자만 필요
  → 회전 행렬(9개)보다 효율적

✓ 수치적 안정성
  → 정규화 쉬움 (크기=1 유지)
```

### 단점

```
✗ 직관적이지 않음
  → 사람이 이해하기 어려움
  → [0.7, 0.5, 0.5, 0] = ???

하지만...
  → 코드로 자동 변환
  → 개발자는 내부만 이해하면 됨
```

---

## 하단: 변환 방법

### 오일러각 → 쿼터니언

```cpp
Quatf euler_to_quaternion(float roll, float pitch, float yaw)
{
    float cr = cos(roll * 0.5f);
    float sr = sin(roll * 0.5f);
    float cp = cos(pitch * 0.5f);
    float sp = sin(pitch * 0.5f);
    float cy = cos(yaw * 0.5f);
    float sy = sin(yaw * 0.5f);
    
    Quatf q;
    q.w = cr * cp * cy + sr * sp * sy;
    q.x = sr * cp * cy - cr * sp * sy;
    q.y = cr * sp * cy + sr * cp * sy;
    q.z = cr * cp * sy - sr * sp * cy;
    
    return q;
}
```

### 쿼터니언 → 오일러각

```cpp
Vector3f quaternion_to_euler(const Quatf &q)
{
    Vector3f euler;
    
    // Roll (x-axis rotation)
    float sinr_cosp = 2 * (q.w * q.x + q.y * q.z);
    float cosr_cosp = 1 - 2 * (q.x * q.x + q.y * q.y);
    euler(0) = atan2(sinr_cosp, cosr_cosp);
    
    // Pitch (y-axis rotation)
    float sinp = 2 * (q.w * q.y - q.z * q.x);
    euler(1) = asin(sinp);
    
    // Yaw (z-axis rotation)
    float siny_cosp = 2 * (q.w * q.z + q.x * q.y);
    float cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
    euler(2) = atan2(siny_cosp, cosy_cosp);
    
    return euler;
}
```

---

## 발표 스크립트

"왜 쿼터니언을 사용할까요? 오일러각의 치명적 약점인 Gimbal Lock 때문입니다.

오일러각으로 회전을 표현하면, Pitch가 90도가 되는 순간 Roll 축과 Yaw 축이 겹쳐버립니다. 드론이 수직으로 세워진 상태에서 좌우 회전이 불가능해지는 것이죠. 이를 Gimbal Lock이라 합니다.

쿼터니언은 4개의 숫자로 회전을 표현하며, 모든 자세를 표현할 수 있고 Gimbal Lock이 절대 발생하지 않습니다. 또한 연산량도 적고 수치적으로 안정적입니다.

단점은 직관적이지 않다는 것인데, 우리는 코드로 자동 변환하므로 내부 동작 원리만 이해하면 됩니다."

---
---

# 슬라이드 16: Level 3/4 - 위치/속도 제어

## 제목
**Level 3/4: 위치/속도 제어**

## 부제목
물리 법칙: 기울여야 이동한다

---

## 상단: 역할 설명

```
┌────────────────────────────────────────────┐
│ 역할: 위치 오차 → 속도 → 가속도 → 자세     │
│ 주파수: 50 Hz                               │
│ 핵심: 물리적 힘 분해                        │
│ 위치: src/modules/mc_pos_control/          │
│       PositionControl/PositionControl.cpp  │
└────────────────────────────────────────────┘
```

---

## 중단 왼쪽: 코드 (핵심 부분)

```cpp
Output update(const Vector3f &pos_sp, const Vector3f &pos,
              const Vector3f &vel, float yaw_sp)
{
    // ═══════════════════════════════════════
    // Step 1: 위치 → 속도 (P 제어)
    // ═══════════════════════════════════════
    Vector3f pos_error = pos_sp - pos;
    // 예시: [3,0,-5] - [0,0,-5] = [3,0,0] m
    
    Vector3f vel_sp = _gain_pos_p * pos_error;
    // 예시: 1.0 × [3,0,0] = [3,0,0] m/s
    
    vel_sp = constrain_norm(vel_sp, 5.0f);  // 최대 5m/s
    
    
    // ═══════════════════════════════════════
    // Step 2: 속도 → 가속도 (PID 제어)
    // ═══════════════════════════════════════
    Vector3f vel_error = vel_sp - vel;
    // 예시: [3,0,0] - [0.2,0,0] = [2.8,0,0] m/s
    
    Vector3f accel_p = _gain_vel_p * vel_error;
    Vector3f accel_i = _gain_vel_i * _vel_integral;
    Vector3f accel_d = _gain_vel_d * vel_derivative;
    
    Vector3f accel_sp = accel_p + accel_i + accel_d;
    // 예시: [8.96, 0, 0] m/s²
    
    
    // ═══════════════════════════════════════
    // Step 3: 가속도 → 자세 (물리 법칙)
    // ═══════════════════════════════════════
    float pitch_sp = atan2(accel_sp(0), _gravity);
    float roll_sp = -atan2(accel_sp(1), _gravity);
    
    // 예시:
    // pitch_sp = atan2(8.96, 9.81) 
    //          = 0.74 rad = 42°
    
    // 🔍 의미:
    // "초당 8.96m/s²로 가속하려면
    //  42도 기울여야 함"
    
    Output output;
    output.attitude = Vector3f(roll_sp, pitch_sp, yaw_sp);
    output.thrust = calculate_thrust(accel_sp);
    
    return output;
}
```

---

## 중단 오른쪽: 물리 법칙 설명

### 정지 호버

```
   ↑ T = mg (추력)
   │
 ┌─┴─┐
 │ ⊕ │ 드론
 └───┘
   │
   ↓ mg (중력)

수직력만 존재
→ 수평 이동 없음
```

### 전진 가속

```
    ↗ T (추력)
   /│
  / │ 수직: T·cos(θ) = mg
 /  │ 수평: T·sin(θ) = ma
┌───┐
│ ⊕ │ θ도 기울임
└───┘
 │
 ↓ mg (중력)

수평력 발생
→ 가속도 a = (T/m)·sin(θ)
→ θ = atan2(a, g)
```

### 예시 계산

```
필요한 가속도: a = 8.96 m/s²
중력: g = 9.81 m/s²

θ = atan2(8.96, 9.81)
  = 0.74 rad
  = 42.4°

의미: "초당 8.96m/s² 가속하려면
      42.4도 기울여야 함"
```

---

## 하단: 게인 값

```
┌─────────────────────────────────┐
│ 위치 제어 게인                   │
├─────────────────────────────────┤
│ Kp_pos = 1.0                    │
├─────────────────────────────────┤
│ 속도 제어 게인                   │
├─────────────────────────────────┤
│ Kp_vel = 3.0                    │
│ Ki_vel = 0.4                    │
│ Kd_vel = 0.2                    │
├─────────────────────────────────┤
│ 제한                            │
├─────────────────────────────────┤
│ 최대 속도: 5 m/s                │
│ 최대 각도: ±30°                 │
└─────────────────────────────────┘
```

---

## 발표 스크립트

"Level 3/4는 위치와 속도를 제어합니다. 먼저 위치 오차를 목표 속도로 변환하고, 속도 오차를 가속도 명령으로 변환합니다.

핵심은 Step 3입니다. 수평 방향으로 가속하려면 드론을 기울여야 합니다. 왜일까요?

정지 호버 상태에서는 추력이 정확히 위를 향해 중력과 균형을 이룹니다. 하지만 전진하려면 추력의 일부가 수평 방향을 향해야 합니다.

물리 법칙에 따라 수평 가속도 a = (T/m)·sin(θ)입니다. 이를 역산하면 θ = atan2(a, g)가 됩니다.

예를 들어 8.96 m/s²로 가속하려면 42.4도 기울여야 합니다. 이것이 드론이 이동할 때 기울어지는 이유입니다."

---
---

# 슬라이드 17: 전체 시스템 데이터 흐름

## 제목
**실제 비행: 전체 데이터 흐름**

## 부제목
"3m 전진" 명령의 전체 처리 과정

---

## 명령 입력

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  명령: "3m 전진하라"
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 데이터 흐름

### 센서 데이터 (EKF 출력)

```
┌──────────────────────────────────┐
│ 📡 센서 (EKF 출력)                │
├──────────────────────────────────┤
│ 위치: [0, 0, -5] m                │
│ 속도: [0, 0, 0] m/s               │
│ 자세: [0°, 0°, 0°]                │
│ 각속도: [0, 0, 0] deg/s           │
└──────────────────────────────────┘
         ↓
```

### Level 4: 위치 제어

```
┌──────────────────────────────────┐
│ 🎯 Level 4: 위치 제어 @ 50Hz     │
├──────────────────────────────────┤
│ pos_error = [3, 0, 0] m           │
│ vel_sp = 1.0 × [3,0,0]            │
│        = [3, 0, 0] m/s            │
└──────────────────────────────────┘
         ↓
```

### Level 3: 속도 제어

```
┌──────────────────────────────────┐
│ 🚀 Level 3: 속도 제어 @ 50Hz     │
├──────────────────────────────────┤
│ vel_error = [3, 0, 0] m/s         │
│ accel_sp = [9.0, 0, 0] m/s²       │
│ attitude_sp = [0°, 42°, 0°]       │
│                                  │
│ 💡 "42도 기울여야 함"            │
└──────────────────────────────────┘
         ↓
```

### Level 2: 자세 제어

```
┌──────────────────────────────────┐
│ 🔄 Level 2: 자세 제어 @ 250Hz    │
├──────────────────────────────────┤
│ attitude_error = [0°, 42°, 0°]    │
│ rate_sp = [0, 273, 0] deg/s       │
│                                  │
│ 💡 "초당 273도로 기울어!"         │
└──────────────────────────────────┘
         ↓
```

### Level 1: 각속도 제어

```
┌──────────────────────────────────┐
│ ⚡ Level 1: 각속도 제어 @ 1000Hz  │
├──────────────────────────────────┤
│ rate_error = [0, 273, 0] deg/s    │
│ torque = [0, 1.0, 0] (최대!)      │
│                                  │
│ 💡 "최대 토크로 회전!"            │
└──────────────────────────────────┘
         ↓
```

### 모터 믹싱

```
┌──────────────────────────────────┐
│ 🔧 모터 믹싱                      │
├──────────────────────────────────┤
│ M1 (전방 우): 0.15                │
│ M2 (전방 좌): 0.15                │
│ M3 (후방 좌): 1.00 (최대!)        │
│ M4 (후방 우): 1.00 (최대!)        │
│                                  │
│ 💡 전방 모터 약하게               │
│    후방 모터 최대                 │
│    → 앞으로 기울어짐              │
└──────────────────────────────────┘
         ↓
```

### 결과

```
┌──────────────────────────────────┐
│ ✈️ 드론 움직임                    │
├──────────────────────────────────┤
│                                  │
│     M3 ████  ████ M4             │
│       ╲      ╱                   │
│        ╲    ╱                    │
│         ╲  ╱  ↗ (앞으로 기울어짐) │
│          ╲╱                      │
│       M1 ▓▓  ▓▓ M2               │
│                                  │
└──────────────────────────────────┘
```

---

## 하단: 시간 흐름

```
0.000s: 명령 수신
0.020s: Level 4 계산 (50Hz)
0.020s: Level 3 계산 (50Hz)
0.024s: Level 2 계산 (250Hz)
0.025s: Level 1 계산 (1000Hz)
0.025s: 모터 출력
0.100s: 드론이 기울어지기 시작
0.500s: 가속 중
2.500s: 감속 시작
3.000s: 목표 도착
```

---

## 발표 스크립트

"이제 전체 흐름을 봅시다. '3m 전진'이라는 명령이 들어오면 어떻게 처리될까요?

먼저 EKF가 현재 상태를 제공합니다. Level 4 위치 제어기는 3m 오차를 감지하고 3 m/s의 목표 속도를 생성합니다.

Level 3 속도 제어기는 이를 9.0 m/s²의 가속도로 변환하고, 물리 법칙에 따라 42도 기울여야 한다고 계산합니다.

Level 2 자세 제어기는 현재 0도에서 42도로 가려면 초당 273도로 회전해야 한다고 계산합니다.

Level 1 각속도 제어기는 273 deg/s의 큰 오차를 감지하고 최대 토크 1.0을 출력합니다.

모터 믹싱에서는 전방 모터는 약하게(0.15), 후방 모터는 최대(1.0)로 설정하여 드론이 앞으로 기울어지게 합니다.

이 모든 과정이 불과 25밀리초 안에 일어납니다."

---
---

# 슬라이드 18: 시간대별 비행 분석

## 제목
**3m 전진 미션: 시간대별 분석**

## 부제목
위치, 속도, 자세, 각속도의 변화

---

## 4개 그래프 (세로 배치)

### 그래프 1: 위치

```
위치 (X축) [m]
3.0 ┤                           ╭─────────
2.5 ┤                     ╭─────╯
2.0 ┤              ╭──────╯
1.5 ┤         ╭────╯
1.0 ┤    ╭────╯
0.5 ┤╭───╯
0.0 ┼╯────────────────────────────────────
    0   0.5  1.0  1.5  2.0  2.5  3.0  [s]
    
    ├──┤├─────┤├───────┤├──┤
    가속  등속   감속   도착
```

**해석:**
- 0~0.5s: 가속 단계 (S자 곡선)
- 0.5~2.0s: 등속 비행
- 2.0~2.8s: 감속 단계
- 2.8~3.0s: 목표 도착

---

### 그래프 2: 속도

```
속도 (X축) [m/s]
2.0 ┤        ╭────────────╮
1.5 ┤    ╭───╯            ╰───╮
1.0 ┤╭───╯                    ╰──╮
0.5 ┤╯                           ╰─╮
0.0 ┼────────────────────────────────╰──
    0   0.5  1.0  1.5  2.0  2.5  3.0  [s]
```

**해석:**
- 최대 약 2 m/s 도달
- 부드러운 가속/감속
- 목표 지점에서 0으로 수렴

---

### 그래프 3: Pitch 각도

```
Pitch 각도 [deg]
40  ┤╭╮
30  ┤│╰───╮
20  ┤│    ╰──╮
10  ┤│       ╰────╮      ╭╮
0   ┼╯            ╰──────╯╰────────────
-10 ┤                      ╰╮
-15 ┤                       ╰─╮
    0   0.5  1.0  1.5  2.0  2.5  3.0  [s]
    
    전방       유지       후방
    기울임               기울임
                        (제동)
```

**해석:**
- 0~0.2s: 급격히 전방으로 기울임 (최대 42도)
- 0.2~2.0s: 일정 각도 유지 (등속)
- 2.0~2.5s: 후방으로 기울여 제동 (최대 -15도)
- 2.5~3.0s: 수평 복귀

---

### 그래프 4: 각속도 (Pitch)

```
각속도 (Pitch) [deg/s]
250 ┤╭╮
150 ┤│╰─╮
50  ┤│  ╰──────╮
0   ┼╯         ╰────────╮      ╭─────
-50 ┤                   ╰──╮ ╭─╯
-130┤                      ╰─╯
    0   0.5  1.0  1.5  2.0  2.5  3.0  [s]
```

**해석:**
- 0~0.1s: 급격한 정방향 회전 (최대 273 deg/s)
- 0.1~0.2s: 감속하며 각도 유지
- 2.0~2.3s: 역방향 회전 (제동용, 최대 -130 deg/s)
- 2.3~3.0s: 안정화

---

## 하단: 각 단계별 해석

```
┌────────────────────────────────────────┐
│ ⏱️ 0~0.5s: 가속 단계                   │
├────────────────────────────────────────┤
│ • 최대 각도로 기울임 (42°)              │
│ • 속도 급상승                          │
│ • PID 모든 항 활발                     │
└────────────────────────────────────────┘

┌────────────────────────────────────────┐
│ ⏱️ 0.5~2.0s: 등속 비행                 │
├────────────────────────────────────────┤
│ • 일정 각도 유지 (약 15°)              │
│ • 안정적 속도                          │
│ • 주로 P항만 작동                      │
└────────────────────────────────────────┘

┌────────────────────────────────────────┐
│ ⏱️ 2.0~2.8s: 감속 단계                 │
├────────────────────────────────────────┤
│ • 후방으로 기울임 (-15°)               │
│ • 속도 감소                            │
│ • I항이 누적 오차 제거                 │
└────────────────────────────────────────┘

┌────────────────────────────────────────┐
│ ⏱️ 2.8~3.0s: 안정화                    │
├────────────────────────────────────────┤
│ • 수평 복귀 (0°)                       │
│ • 정밀 위치 제어                       │
│ • I항의 정상상태 오차 제거 중요        │
└────────────────────────────────────────┘
```

---

## 발표 스크립트

"이제 시간대별 그래프를 봅시다. 4개 그래프가 어떻게 연결되는지 보세요.

첫 0.1초 동안 각속도가 273 deg/s로 치솟으며 드론이 급격히 기울어집니다. 이때 Pitch 각도가 42도까지 올라갑니다. 이렇게 기울어지면 속도가 급격히 증가하고 위치도 움직이기 시작합니다.

0.5초~2.0초 구간에서는 일정한 각도를 유지하며 등속 비행합니다. 위치 그래프가 직선에 가까워지는 것을 볼 수 있습니다.

2.0초부터 감속이 시작됩니다. 각속도가 음수로 바뀌며 후방으로 기울어집니다. 최대 -15도까지 기울어지며 제동이 걸립니다.

3.0초에 목표에 도착하며 모든 값이 0으로 수렴합니다. 이것이 PID 4단계 제어가 실제로 작동하는 모습입니다."

---
---

# 슬라이드 19: PID 튜닝 가이드

## 제목
**PID 게인 튜닝: 실전 가이드**

## 부제목
안정적인 비행을 위한 필수 과정

---

## 튜닝 순서 (필수 규칙)

```
⚠️ 반드시 이 순서를 지켜야 합니다!

1단계: Level 1 (Rate Controller)
       각속도 제어부터 안정화
     ↓
2단계: Level 2 (Attitude Controller)
       자세 제어 튜닝
     ↓
3단계: Level 3/4 (Velocity/Position Controller)
       속도/위치 제어 마지막

이유: 하위 루프가 불안정하면
      상위 루프도 반드시 불안정
```

---

## 각 게인의 효과

### P 게인 증가

```
┌────────────────────────────────────┐
│ ✅ 장점                             │
├────────────────────────────────────┤
│ • 빠른 응답 속도                    │
│ • 오차에 즉각 반응                  │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ ❌ 단점                             │
├────────────────────────────────────┤
│ • 진동 발생 (너무 크면)             │
│ • 오버슈트 증가                     │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 🎯 튜닝 방법                        │
├────────────────────────────────────┤
│ 1. P를 천천히 증가                  │
│ 2. 진동이 시작될 때까지 올림        │
│ 3. 진동 시작 값의 70~80%로 설정     │
│                                    │
│ 예시:                              │
│ 진동 시작: Kp = 0.20               │
│ 최종 설정: Kp = 0.15 (75%)         │
└────────────────────────────────────┘
```

---

### I 게인 증가

```
┌────────────────────────────────────┐
│ ✅ 장점                             │
├────────────────────────────────────┤
│ • 정상상태 오차 완전 제거           │
│ • 외란(바람) 보상                   │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ ❌ 단점                             │
├────────────────────────────────────┤
│ • 오버슈트 증가                     │
│ • 진동 주기 증가                    │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 🎯 튜닝 방법                        │
├────────────────────────────────────┤
│ 1. P 튜닝 완료 후 시작              │
│ 2. I=0에서 시작                     │
│ 3. 미세 오차가 남으면 천천히 증가   │
│ 4. 오버슈트가 커지면 중단           │
│                                    │
│ 예시:                              │
│ P 설정 후: Kp = 0.15, Ki = 0       │
│ 미세 오차 발견 → Ki 증가            │
│ 최종: Ki = 0.05                    │
└────────────────────────────────────┘
```

---

### D 게인 증가

```
┌────────────────────────────────────┐
│ ✅ 장점                             │
├────────────────────────────────────┤
│ • 오버슈트 감소                     │
│ • 안정성 대폭 향상                  │
│ • 진동 감쇠                         │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ ❌ 단점                             │
├────────────────────────────────────┤
│ • 고주파 노이즈 증폭                │
│ • 센서 노이즈에 민감                │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 🎯 튜닝 방법                        │
├────────────────────────────────────┤
│ 1. P, I 튜닝 완료 후 시작           │
│ 2. D=0에서 시작                     │
│ 3. 오버슈트가 크면 조금씩 증가      │
│ 4. 고주파 떨림 발생하면 감소        │
│                                    │
│ 예시:                              │
│ P, I 설정 후 오버슈트 발생          │
│ Kd 조금씩 증가: 0.001 → 0.003      │
│ 떨림 없으면 최종 확정               │
└────────────────────────────────────┘
```

---

## 실전 튜닝 체크리스트

```
✓ SITL에서 먼저 테스트 (추락 방지)
✓ 한 번에 한 파라미터만 변경
✓ 변경 후 최소 30초 비행 테스트
✓ 로그 분석으로 수치 확인
✓ 각 변경 사항 기록 (버전 관리)

✗ 여러 파라미터 동시 변경 금지
✗ 실제 드론으로 바로 테스트 금지
✗ 극단적인 값 설정 금지
✗ 로그 없이 감으로 튜닝 금지
```

---

## 튜닝 완료 기준

```
┌────────────────────────────────────┐
│ ✅ 잘 튜닝된 시스템                 │
├────────────────────────────────────┤
│ 1. 빠른 응답 (0.5초 내 도달)        │
│ 2. 오버슈트 < 5%                   │
│ 3. 정상상태 오차 < 5 cm            │
│ 4. 바람에 안정적 (5 m/s까지)       │
│ 5. 진동 없음                       │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"PID 튜닝은 드론 개발에서 가장 중요하면서도 어려운 과정입니다. 반드시 Level 1부터 Level 4 순서로 진행해야 합니다.

P 게인 튜닝은 진동이 시작될 때까지 올린 후, 그 값의 70~80%로 설정합니다. I 게인은 P 튜닝 후에 미세 오차가 남을 때만 천천히 증가시킵니다. D 게인은 오버슈트가 클 때 조금씩 증가시키되, 고주파 떨림이 발생하면 즉시 줄입니다.

실전 팁으로는 반드시 SITL에서 먼저 테스트하고, 한 번에 한 파라미터만 변경하며, 모든 변경 사항을 로그로 기록해야 합니다. 

잘 튜닝된 시스템은 0.5초 내 빠른 응답, 5% 미만의 오버슈트, 5cm 미만의 정상상태 오차를 보입니다."

---
---

# 슬라이드 20: 요약 및 실습 과제

## 제목
**PID 제어 요약 및 실습 안내**

## 부제목
이론에서 실전으로

---

## 핵심 요약

### 4단계 계층 구조

```
Level 4 (위치)  ──→  Level 3 (속도)
   50Hz               50Hz
     ↓                  ↓
Level 2 (자세)  ──→  Level 1 (각속도)
   250Hz              1000Hz
```

### P-I-D의 역할

```
P (비례):  스프링  → 즉각 반응
I (적분):  기억   → 정상상태 오차 제거
D (미분):  댐퍼   → 오버슈트 방지
```

### 물리 법칙

```
가속 = 기울임
θ = atan2(a, g)
```

---

## 실습 과제 1: SITL 기본 실습

```
┌────────────────────────────────────┐
│ 목표: PID 동작 관찰                 │
├────────────────────────────────────┤
│ 1. PX4 SITL 환경 구축               │
│ 2. QGroundControl 연결              │
│ 3. 기본 비행 테스트                 │
│    - 이륙 (Takeoff)                │
│    - 호버링 (Hover)                │
│    - 웨이포인트 비행                │
│ 4. 로그 분석                        │
│    - ekf2_innovations 확인          │
│    - vehicle_attitude 확인          │
└────────────────────────────────────┘

예상 시간: 1~2시간
난이도: ★☆☆☆☆
```

---

## 실습 과제 2: PID 게인 튜닝

```
┌────────────────────────────────────┐
│ 목표: 게인 변화 효과 체험           │
├────────────────────────────────────┤
│ 1. Rate Controller P 게인 변경      │
│    MC_ROLLRATE_P: 0.15 → 0.30      │
│    결과: 진동 발생 관찰             │
│                                    │
│ 2. I 게인 추가                      │
│    MC_ROLLRATE_I: 0 → 0.10         │
│    결과: 오버슈트 관찰              │
│                                    │
│ 3. D 게인 추가                      │
│    MC_ROLLRATE_D: 0 → 0.005        │
│    결과: 안정화 관찰                │
│                                    │
│ 4. 최적값 찾기                      │
│    진동 없는 최대 P 게인            │
└────────────────────────────────────┘

예상 시간: 2~3시간
난이도: ★★★☆☆
```

---

## 실습 과제 3: 코드 분석

```
┌────────────────────────────────────┐
│ 목표: 실제 코드 이해                │
├────────────────────────────────────┤
│ 1. PX4 소스코드 다운로드            │
│                                    │
│ 2. RateControl.cpp 열기             │
│    위치: src/lib/rate_control/     │
│                                    │
│ 3. update() 함수 분석               │
│    - 각 줄의 역할 주석 달기         │
│    - P, I, D 계산 부분 찾기         │
│                                    │
│ 4. 자신만의 게인으로 수정           │
│    - Kp, Ki, Kd 변경               │
│    - 컴파일 및 SITL 테스트          │
└────────────────────────────────────┘

예상 시간: 3~4시간
난이도: ★★★★☆
```

---

## 실습 환경 선택

### 옵션 A: PX4 SITL (추천)

```
장점:
✓ 실제 환경과 동일
✓ 완전한 기능
✓ QGroundControl 연동

단점:
✗ Ubuntu 필요
✗ 초기 설치 1시간

추천 대상: 실무 준비 학생
```

### 옵션 B: Python 시뮬레이터

```
장점:
✓ 빠른 설치 (10분)
✓ 코드 수정 쉬움
✓ 모든 OS 지원

단점:
✗ 간단한 물리 모델
✗ 실제와 차이

추천 대상: 알고리즘 이해 우선
```

---

## 추가 학습 자료

```
📚 공식 문서
- PX4 Docs: https://docs.px4.io
- ArduPilot Wiki: https://ardupilot.org

📹 동영상
- PX4 SITL Tutorial (YouTube)
- PID Tuning Guide (YouTube)

📖 논문
- "Quadrotor Control: State of the Art"
- "Cascaded PID Control for UAVs"

💻 코드 저장소
- PX4-Autopilot GitHub
- ArduPilot GitHub
```

---

## 다음 주 예고

```
┌────────────────────────────────────┐
│ 4주차: 모터 믹싱 & 통신 프로토콜    │
├────────────────────────────────────┤
│ • 모터 믹싱 알고리즘                │
│ • MAVLink 프로토콜                  │
│ • GCS 연동                          │
│ • 실제 하드웨어 테스트              │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"오늘 배운 내용을 정리하겠습니다. PID 제어는 4단계 계층으로 구성되며, 각 레벨은 독립적으로 동작합니다. P는 스프링처럼 즉각 반응하고, I는 누적 오차를 제거하며, D는 댐퍼처럼 오버슈트를 방지합니다.

실습 과제는 3단계로 준비했습니다. 먼저 SITL 환경에서 기본 비행을 테스트하고, PID 게인을 직접 변경하며 효과를 관찰하고, 마지막으로 실제 소스코드를 분석합니다.

실습 환경은 PX4 SITL과 Python 시뮬레이터 중 선택할 수 있습니다. 실무를 준비하는 분들은 PX4 SITL을, 알고리즘 이해가 우선인 분들은 Python 시뮬레이터를 추천합니다.

다음 주에는 모터 믹싱과 MAVLink 프로토콜을 배웁니다. 질문 있으신가요?"

---
---

# 🎓 부록: 발표 팁

## 시간 배분 (50분 기준)

```
슬라이드 9-10: 전체 구조 (10분)
슬라이드 11-13: 각 레벨 상세 (15분)
슬라이드 14-16: 물리 법칙 (10분)
슬라이드 17-18: 실전 분석 (10분)
슬라이드 19-20: 튜닝 & 실습 (5분)
```

## 강조 포인트

```
1. "왜?"를 강조
   - 왜 4단계로 나누는가?
   - 왜 P만으로 부족한가?
   - 왜 쿼터니언을 쓰는가?

2. 실제 숫자 예시 반복
   - 추상적 설명 후 항상 예시
   - "예를 들어, 8도 오차면..."

3. 학생 참여 유도
   - "여러분 생각엔 어떨까요?"
   - "바람이 불면 어떻게 될까요?"
```

## 질문 대응

```
Q: "PID 말고 다른 제어 방법은?"
A: "MPC, LQR 등이 있지만, 
    PID가 가장 검증되고 효율적입니다.
    다음 주차에 다룹니다."

Q: "게인 값은 어떻게 정해지나요?"
A: "기체마다 다릅니다. 
    무게, 크기, 모터 성능에 따라
    실험적으로 튜닝합니다."

Q: "실제 드론에 적용 가능한가요?"
A: "네, 이 코드는 PX4 실제 코드입니다.
    Pixhawk에서 그대로 작동합니다."
```

---

**이 자료를 사용하여 성공적인 발표 되시길 바랍니다! 🚁**
