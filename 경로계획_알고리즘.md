# UAV 4주차 PPT - 경로 계획 알고리즘 완전판

목표까지 안전하게 이동하는 경로 생성

---

# 슬라이드 42: 경로 계획 개요

## 제목
**알고리즘 4: 경로 계획 (Path Planning)**

## 부제목
출발점에서 목표점까지 최적 경로 생성

---

## 왼쪽 영역: 역할 설명

```
┌──────────────────────────────────────┐
│ 입력                                  │
├──────────────────────────────────────┤
│ • 시작 위치:   [0, 0, -10] m         │
│ • 목표 위치:   [100, 50, -20] m      │
│ • 장애물 지도: 3D 점군/그리드         │
│ • 제약 조건:   최대 속도, 가속도      │
└──────────────────────────────────────┘
           ↓
    [경로 계획 알고리즘]
           ↓
┌──────────────────────────────────────┐
│ 출력 (웨이포인트 리스트)              │
├──────────────────────────────────────┤
│ WP1: [10, 5, -10] m                  │
│ WP2: [30, 15, -12] m                 │
│ WP3: [50, 30, -15] m                 │
│ WP4: [70, 40, -18] m                 │
│ WP5: [100, 50, -20] m (목표)         │
│                                      │
│ 총 거리: 112.5 m                     │
│ 예상 시간: 45초 (평균 2.5 m/s)       │
└──────────────────────────────────────┘
```

---

## 중단: 핵심 역할

### 📌 3가지 주요 기능

**1. 경로 탐색 (Path Search)**
- 시작 → 목표 연결하는 경로 찾기
- 최단 경로 or 최적 경로
- 장애물 회피

**2. 경로 최적화 (Path Smoothing)**
- 직선 경로로 단순화
- 불필요한 웨이포인트 제거
- 드론 동역학 고려

**3. 실시간 재계획 (Re-planning)**
- 새로운 장애물 발견 시
- 바람 등 외란 대응
- 동적 환경 대응

---

## 오른쪽 영역: 왜 필요한가?

### 수동 vs 자동

```
┌────────────────────────────────────┐
│ 수동 조종 (Manual)                  │
├────────────────────────────────────┤
│ ✓ 실시간 반응                      │
│ ✗ 조종사 피로                      │
│ ✗ 긴 미션 불가능                   │
│ ✗ 장애물 회피 어려움               │
│ ✗ 최적 경로 보장 없음              │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 자율 비행 (Autonomous)              │
├────────────────────────────────────┤
│ ✓ 최적 경로                        │
│ ✓ 반복 가능                        │
│ ✓ 장거리 미션                      │
│ ✓ 자동 장애물 회피                 │
│ ✓ 멀티 드론 협업                   │
└────────────────────────────────────┘

응용:
• 농업: 넓은 농장 자동 스캔
• 배송: 도심 경로 최적화
• 점검: 송전선 자동 추적
• 수색: 넓은 지역 체계적 탐색
```

---

## 하단: 실행 특성

```
┌────────────────────────────────────┐
│ 계획 단계 (Planning Phase)          │
├────────────────────────────────────┤
│ 타이밍: 미션 전 or 비행 중          │
│ 주파수: 0.1 ~ 10 Hz                │
│ 입력: 지도, 시작, 목표              │
│ 출력: 웨이포인트 리스트             │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 추종 단계 (Following Phase)         │
├────────────────────────────────────┤
│ 타이밍: 비행 중 지속                │
│ 주파수: 50 Hz (Position Controller)│
│ 입력: 현재 위치, 다음 웨이포인트     │
│ 출력: 속도 명령                    │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 위치                               │
├────────────────────────────────────┤
│ PX4: src/modules/navigator/        │
│      mission.cpp, rtl.cpp          │
│                                    │
│ ArduPilot: libraries/AP_Mission/   │
│            AP_Mission.cpp          │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"경로 계획은 출발점에서 목표점까지 최적 경로를 생성하는 알고리즘입니다. 이것은 자율 비행의 핵심입니다.

입력은 시작 위치, 목표 위치, 장애물 지도, 제약 조건입니다. 출력은 웨이포인트 리스트입니다. 예를 들어 100m 이동에 5개 웨이포인트를 생성하고 총 거리 112.5m, 예상 시간 45초를 계산합니다.

3가지 주요 기능이 있습니다. 경로 탐색은 시작과 목표를 연결하는 경로를 찾습니다. 경로 최적화는 불필요한 웨이포인트를 제거하여 직선화합니다. 실시간 재계획은 새로운 장애물이나 외란에 대응합니다.

수동 조종은 실시간 반응은 좋지만 조종사가 피로하고 긴 미션이 불가능하며 최적 경로를 보장할 수 없습니다. 자율 비행은 최적 경로, 반복 가능성, 장거리 미션, 자동 장애물 회피, 멀티 드론 협업이 가능합니다.

농업에서는 넓은 농장을 자동 스캔하고, 배송에서는 도심 경로를 최적화하며, 점검에서는 송전선을 자동 추적하고, 수색에서는 넓은 지역을 체계적으로 탐색합니다.

계획 단계는 미션 전이나 비행 중 0.1~10Hz로 실행되어 웨이포인트 리스트를 생성합니다. 추종 단계는 비행 중 50Hz로 지속 실행되어 속도 명령을 출력합니다."

---

## 이미지/다이어그램 추천

1. **3D 경로 시각화**: 장애물과 경로 표시
2. **GCS 화면**: Mission Planner/QGroundControl
3. **웨이포인트 시퀀스**: 시작 → WP1 → WP2 → 목표

---
---

# 슬라이드 43: 경로 계획 알고리즘 분류

## 제목
**경로 계획 알고리즘 종류**

## 부제목
그래프 기반 vs 샘플링 기반

---

## 상단: 알고리즘 분류

```
┌──────────────────────────────────────┐
│ 그래프 기반 (Graph-based)             │
├──────────────────────────────────────┤
│ • 공간을 그래프로 표현                │
│ • 노드 + 엣지                        │
│ • 완전성 보장 (해 존재 시 발견)       │
│ • 최적성 보장 가능                   │
│                                      │
│ 알고리즘:                            │
│ - Dijkstra (다익스트라)              │
│ - A* (에이 스타)                     │
│ - D* (Dynamic A*)                    │
└──────────────────────────────────────┘

┌──────────────────────────────────────┐
│ 샘플링 기반 (Sampling-based)          │
├──────────────────────────────────────┤
│ • 랜덤 샘플링                        │
│ • 고차원 공간 적합                   │
│ • 확률적 완전성                      │
│ • 빠른 계산                          │
│                                      │
│ 알고리즘:                            │
│ - RRT (Rapidly-exploring Random Tree)│
│ - PRM (Probabilistic Roadmap)        │
│ - RRT*                               │
└──────────────────────────────────────┘
```

---

## 중단 왼쪽: 그래프 기반 (Grid Map)

### 2D 그리드 예시

```
S = 시작, G = 목표, # = 장애물, . = 자유

. . . . . . . . . G
. . # # # # . . . .
. . # . . # . . . .
. . # . . # # # . .
. . . . . . . . . .
. # # # . . . . . .
. . . # . . # # # .
. . . . . . . . . .
S . . . . . . . . .

그래프 표현:
각 셀 = 노드
인접 셀 = 엣지 (8방향 또는 4방향)
```

**Dijkstra 탐색:**
```
1. 시작 노드 거리 = 0
2. 우선순위 큐에 추가
3. 최소 거리 노드 선택
4. 인접 노드 거리 업데이트
5. 목표 도달까지 반복

시간 복잡도: O((V+E) log V)
공간 복잡도: O(V)
```

---

## 중단 오른쪽: 샘플링 기반 (RRT)

### RRT 성장 과정

```
t=0: 시작점만
    S

t=1: 랜덤 샘플 → 가장 가까운 노드 확장
    S───●

t=2: 반복
    S───●
         ╲
          ●

t=10: 트리 성장
    S───●───●───●
     ╲   ╲
      ●   ●───●
       ╲
        ●───●───G (목표 도달!)

특징:
✓ 고차원 공간 (3D, 6D 등)
✓ 복잡한 장애물
✗ 최적성 보장 없음 (RRT* 사용 시 보장)
```

---

## 하단: 비교표

| 항목 | Dijkstra | A* | RRT | PRM |
|------|----------|-----|-----|-----|
| **완전성** | ✓ | ✓ | 확률적 | 확률적 |
| **최적성** | ✓ | ✓ | ✗ (RRT*: ✓) | 확률적 |
| **속도** | 느림 | 빠름 | 매우 빠름 | 중간 |
| **차원** | 2D-3D | 2D-3D | 고차원 | 고차원 |
| **메모리** | 높음 | 높음 | 낮음 | 중간 |
| **재계획** | 전체 | 전체 | 부분 | 부분 |
| **드론 사용** | ★☆☆ | ★★★ | ★★☆ | ★☆☆ |

---

## 사용 시나리오

```
┌────────────────────────────────────┐
│ A* (가장 많이 사용)                 │
├────────────────────────────────────┤
│ • 2D/3D 그리드 맵                   │
│ • 정적 환경                        │
│ • 최적 경로 필요                   │
│ • 사전 계획                        │
│                                    │
│ 예: 농업 스캔, 웨이포인트 미션      │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ RRT (실시간 계획)                   │
├────────────────────────────────────┤
│ • 복잡한 3D 환경                   │
│ • 동적 장애물                      │
│ • 빠른 재계획                      │
│ • 실시간 요구                      │
│                                    │
│ 예: 실내 비행, 장애물 회피          │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"경로 계획 알고리즘은 크게 그래프 기반과 샘플링 기반으로 나뉩니다.

그래프 기반은 공간을 노드와 엣지의 그래프로 표현합니다. Dijkstra와 A*가 대표적입니다. 완전성과 최적성을 보장하지만 메모리 사용이 높고 고차원 공간에 부적합합니다.

2D 그리드 예시를 보면 각 셀이 노드이고 인접 셀이 엣지입니다. Dijkstra는 시작 노드부터 거리를 업데이트하며 최단 경로를 찾습니다.

샘플링 기반은 랜덤 샘플링으로 경로를 찾습니다. RRT와 PRM이 대표적입니다. 고차원 공간에 적합하고 빠르지만 확률적 완전성만 보장합니다.

RRT 성장 과정을 보면 시작점에서 랜덤 샘플을 생성하고 가장 가까운 노드를 확장합니다. 트리가 성장하여 목표에 도달합니다. 3D, 6D 같은 고차원 공간과 복잡한 장애물에 효과적이지만 최적성은 보장되지 않습니다.

비교표를 보면 A*가 완전성, 최적성, 속도가 균형 잡혀 드론에 가장 많이 사용됩니다. RRT는 실시간 재계획에 유리합니다.

A*는 2D/3D 그리드 맵, 정적 환경, 사전 계획이 필요한 농업 스캔이나 웨이포인트 미션에 적합합니다. RRT는 복잡한 3D 환경, 동적 장애물, 실시간 재계획이 필요한 실내 비행이나 장애물 회피에 적합합니다."

---
---

# 슬라이드 44: A* 알고리즘 상세

## 제목
**A* (A-Star) 알고리즘**

## 부제목
휴리스틱으로 최적 경로 빠르게 찾기

---

## 상단: A*의 핵심 아이디어

```
Dijkstra의 한계:
모든 방향을 동일하게 탐색
→ 목표와 반대 방향도 탐색
→ 비효율적

A*의 개선:
목표 방향 우선 탐색
→ 휴리스틱 함수 h(n) 사용
→ 훨씬 빠름!
```

---

## 중단: A* 수식

### 비용 함수

```
f(n) = g(n) + h(n)

f(n): 총 예상 비용
g(n): 시작 → n까지 실제 비용
h(n): n → 목표까지 예상 비용 (휴리스틱)

예시:
시작 S, 목표 G, 현재 노드 n

g(n) = 15 (S에서 n까지 실제 이동 거리)
h(n) = 8  (n에서 G까지 직선 거리)
f(n) = 23 (총 예상 비용)
```

---

### 휴리스틱 함수

```
┌────────────────────────────────────┐
│ 2D 공간                             │
├────────────────────────────────────┤
│ 맨하탄 거리 (Manhattan):            │
│ h(n) = |x_n - x_g| + |y_n - y_g|   │
│                                    │
│ 유클리드 거리 (Euclidean):          │
│ h(n) = √[(x_n-x_g)² + (y_n-y_g)²]  │
│                                    │
│ 체비셰프 거리 (Chebyshev):          │
│ h(n) = max(|x_n-x_g|, |y_n-y_g|)   │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 3D 공간 (드론)                      │
├────────────────────────────────────┤
│ h(n) = √[(x_n-x_g)² + (y_n-y_g)²   │
│           + (z_n-z_g)²]            │
│                                    │
│ 또는 가중치 추가:                   │
│ h(n) = w_xy × dist_xy +            │
│        w_z × dist_z                │
│                                    │
│ (고도 변화 비용 다르게 설정)        │
└────────────────────────────────────┘
```

---

## 하단: 완전한 코드

```python
import heapq
import numpy as np

def astar(start, goal, grid):
    """
    A* 경로 계획
    
    Args:
        start: (x, y) 시작 위치
        goal: (x, y) 목표 위치
        grid: 2D numpy array (0=자유, 1=장애물)
    
    Returns:
        path: 웨이포인트 리스트 또는 None
    """
    
    # ═══════════════════════════════════════
    # Step 1: 초기화
    # ═══════════════════════════════════════
    rows, cols = grid.shape
    
    # Open list (우선순위 큐)
    open_list = []
    heapq.heappush(open_list, (0, start))
    
    # Closed set (방문한 노드)
    closed_set = set()
    
    # 각 노드의 g, f 값
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}
    
    # 경로 추적용 (각 노드의 부모)
    came_from = {}
    
    
    # ═══════════════════════════════════════
    # Step 2: 휴리스틱 함수
    # ═══════════════════════════════════════
    def heuristic(pos, goal):
        # 유클리드 거리
        return np.sqrt((pos[0]-goal[0])**2 + 
                       (pos[1]-goal[1])**2)
    
    
    # ═══════════════════════════════════════
    # Step 3: 이웃 노드 생성 (8방향)
    # ═══════════════════════════════════════
    def get_neighbors(pos):
        x, y = pos
        neighbors = []
        
        # 8방향: 상하좌우 + 대각선
        directions = [
            (-1, 0), (1, 0), (0, -1), (0, 1),      # 상하좌우
            (-1, -1), (-1, 1), (1, -1), (1, 1)    # 대각선
        ]
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            # 범위 체크
            if 0 <= nx < rows and 0 <= ny < cols:
                # 장애물 체크
                if grid[nx, ny] == 0:
                    neighbors.append((nx, ny))
        
        return neighbors
    
    
    # ═══════════════════════════════════════
    # Step 4: A* 메인 루프
    # ═══════════════════════════════════════
    while open_list:
        # f 값이 가장 작은 노드 선택
        _, current = heapq.heappop(open_list)
        
        # 목표 도달?
        if current == goal:
            # 경로 재구성
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            path.reverse()
            return path
        
        # 방문 표시
        closed_set.add(current)
        
        # 이웃 노드 탐색
        for neighbor in get_neighbors(current):
            if neighbor in closed_set:
                continue
            
            # 대각선: √2, 직선: 1
            if abs(neighbor[0]-current[0]) + \
               abs(neighbor[1]-current[1]) == 2:
                tentative_g = g_score[current] + 1.414
            else:
                tentative_g = g_score[current] + 1.0
            
            # 더 나은 경로 발견?
            if neighbor not in g_score or \
               tentative_g < g_score[neighbor]:
                
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g
                f_score[neighbor] = tentative_g + \
                                   heuristic(neighbor, goal)
                
                heapq.heappush(open_list, 
                              (f_score[neighbor], neighbor))
    
    # 경로 없음
    return None


# ═══════════════════════════════════════
# Step 5: 사용 예시
# ═══════════════════════════════════════
# 10x10 그리드 맵
grid = np.zeros((10, 10))

# 장애물 추가
grid[2:7, 3] = 1  # 세로 벽
grid[4, 3:8] = 1  # 가로 벽

# 경로 탐색
start = (0, 0)
goal = (9, 9)
path = astar(start, goal, grid)

if path:
    print(f"경로 발견! 길이: {len(path)}")
    print(f"웨이포인트: {path}")
else:
    print("경로 없음")
```

---

## 발표 스크립트

"A*는 Dijkstra의 개선 버전으로, 휴리스틱 함수로 목표 방향을 우선 탐색합니다.

핵심 수식은 f(n) = g(n) + h(n)입니다. f(n)은 총 예상 비용, g(n)은 시작에서 현재까지 실제 비용, h(n)은 현재에서 목표까지 예상 비용입니다. 예를 들어 g=15, h=8이면 f=23입니다.

휴리스틱 함수는 2D에서 맨하탄, 유클리드, 체비셰프 거리를 사용합니다. 드론 3D 공간에서는 XYZ 유클리드 거리를 사용하거나, 고도 변화 비용을 다르게 가중치를 줄 수 있습니다.

완전한 코드를 봅시다. Step 1에서 우선순위 큐로 open list를 초기화하고, closed set으로 방문 노드를 추적합니다. g_score와 f_score를 딕셔너리로 저장합니다.

Step 2에서 휴리스틱은 유클리드 거리입니다.

Step 3에서 8방향 이웃 노드를 생성합니다. 상하좌우 4방향과 대각선 4방향입니다. 범위와 장애물을 체크합니다.

Step 4 메인 루프에서 f 값이 가장 작은 노드를 선택합니다. 목표 도달 시 came_from으로 경로를 재구성합니다. 각 이웃에 대해 대각선은 1.414, 직선은 1.0 비용으로 g 값을 계산하고, 더 나은 경로면 업데이트합니다.

Step 5 예시에서 10×10 그리드에 L자 장애물을 만들고 (0,0)에서 (9,9)까지 경로를 찾습니다."

---
---

# 슬라이드 45: A* 시각화 및 최적화

## 제목
**A* 탐색 과정 시각화**

## 부제목
단계별 노드 확장

---

## 상단: 탐색 과정

### 그리드 맵 (10×10)

```
S = 시작 (0,0)
G = 목표 (9,9)
# = 장애물
. = 자유 공간
* = 탐색된 노드
→ = 최종 경로

초기 상태:
. . . . . . . . . .
. . . # . . . . . .
. . . # . . . . . .
. . . # . . . . . .
. . . # # # # # . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
S . . . . . . . . G
```

---

### Step 1: 시작 (n=0)

```
Open: [(0, S)]
Closed: {}

. . . . . . . . . .
. . . # . . . . . .
. . . # . . . . . .
. . . # . . . . . .
. . . # # # # # . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
S . . . . . . . . G
↑ 현재
```

---

### Step 5: 초기 확장 (n=5)

```
Open: [...6개 노드...]
Closed: {S, (1,0), (0,1), (1,1)}

* * . . . . . . . .
* * . # . . . . . .
. . . # . . . . . .
. . . # . . . . . .
. . . # # # # # . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
S . . . . . . . . G

f 값이 작은 쪽(목표 방향)으로 확장
```

---

### Step 20: 장애물 우회 (n=20)

```
* * * * . . . . . .
* * * # . . . . . .
* * * # . . . . . .
* * * # . . . . . .
* * * # # # # # . .
* * * * * * * * . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
S . . . . . . . . G

장애물을 왼쪽으로 우회
```

---

### Step 40: 목표 도달 (n=40)

```
→ → → → . . . . . .
. . . # . . . . . .
. . . # . . . . . .
. . . # . . . . . .
. . . # # # # # . .
→ → → → → → → → . .
. . . . . . . . ↓ .
. . . . . . . . ↓ .
. . . . . . . . ↓ .
S . . . . . . . → G

경로 길이: 18
탐색 노드: 40개 (전체 100개 중 40%)
```

---

## 중단: Dijkstra vs A* 비교

### Dijkstra 탐색

```
모든 방향 동일하게 탐색

* * * * * * * . . .
* * * # * * * . . .
* * * # * * * . . .
* * * # * * * . . .
* * * # # # # # . .
* * * * * * * * . .
* * * * * * * * * .
* * * * * * * * * .
* * * * * * * * * *
S * * * * * * * * G

탐색 노드: 80개 (전체의 80%)
```

### A* 탐색

```
목표 방향 우선 탐색

* * * * . . . . . .
* * * # . . . . . .
* * * # . . . . . .
* * * # . . . . . .
* * * # # # # # . .
* * * * * * * * . .
. . . . . . . . * .
. . . . . . . . * .
. . . . . . . . * .
S . . . . . . . * G

탐색 노드: 40개 (전체의 40%)
→ 50% 효율 향상!
```

---

## 하단: 최적화 기법

```
┌────────────────────────────────────┐
│ 1. Tie-breaking                     │
├────────────────────────────────────┤
│ f 값 동일 시 h 값 작은 것 우선      │
│                                    │
│ f(n) = g(n) + (1 + ε) × h(n)       │
│ ε = 0.001 (작은 가중치)            │
│                                    │
│ 효과: 목표에 더 빨리 도달           │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 2. Jump Point Search (JPS)          │
├────────────────────────────────────┤
│ 그리드에서 불필요한 노드 건너뛰기   │
│ 대칭 경로 제거                     │
│                                    │
│ 속도: A* 대비 10~20배 향상          │
│ 복잡도: 구현 어려움                │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 3. Hierarchical A*                  │
├────────────────────────────────────┤
│ 멀티 해상도 맵                     │
│ 거리 멀 때: 저해상도               │
│ 거리 가까울 때: 고해상도            │
│                                    │
│ 효과: 대규모 맵에서 효율적          │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 4. Anytime A*                       │
├────────────────────────────────────┤
│ 실시간 제약: 시간 내 최선 경로      │
│ 계속 개선: 시간 허용 시 최적화      │
│                                    │
│ ε-admissible: 최적 × (1+ε) 보장   │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"A* 탐색 과정을 시각화해봅시다. 10×10 그리드에 L자 장애물이 있고 시작은 (0,0), 목표는 (9,9)입니다.

Step 1에서 시작 노드만 Open list에 있습니다.

Step 5에서 초기 확장으로 *로 표시된 4개 노드를 탐색했습니다. f 값이 작은 목표 방향으로 확장합니다.

Step 20에서 장애물을 만나 왼쪽으로 우회하기 시작합니다.

Step 40에서 목표에 도달했습니다. 화살표가 최종 경로이고 길이는 18입니다. 전체 100개 중 40개만 탐색하여 40% 효율입니다.

Dijkstra는 모든 방향을 동일하게 탐색하여 80개 노드를 탐색합니다. A*는 목표 방향 우선으로 40개만 탐색하여 50% 효율이 향상되었습니다.

최적화 기법 4가지가 있습니다. Tie-breaking은 f 값 동일 시 h 값이 작은 것을 우선하여 목표에 빨리 도달합니다. JPS는 그리드에서 불필요한 노드를 건너뛰어 10~20배 빠르지만 구현이 어렵습니다. Hierarchical A*는 멀티 해상도 맵으로 대규모 맵에서 효율적입니다. Anytime A*는 실시간 제약 시 시간 내 최선 경로를 제공하고, 시간이 허용되면 계속 개선합니다."

---
---

# 슬라이드 46: 웨이포인트 추종

## 제목
**웨이포인트 추종 (Waypoint Following)**

## 부제목
생성된 경로를 실제로 비행하기

---

## 상단: 웨이포인트 구조

### MAVLink 웨이포인트

```cpp
struct Waypoint {
    uint16_t seq;           // 순서 (0, 1, 2, ...)
    uint16_t command;       // MAV_CMD_NAV_WAYPOINT
    float param1;           // 대기 시간 (초)
    float param2;           // 수용 반경 (m)
    float param3;           // 0 (사용 안 함)
    float param4;           // Yaw 각도 (deg)
    float x;                // 위도 (deg × 10^7)
    float y;                // 경도 (deg × 10^7)
    float z;                // 고도 (m, MSL)
    uint8_t frame;          // 좌표계 (MAV_FRAME_*)
    uint8_t autocontinue;   // 1=자동 다음
};
```

**예시:**
```
WP0: (37.5665°N, 126.9780°E, 50m)
     - 대기 5초
     - 수용 반경 2m
     - Yaw 90° (동쪽)
     - 자동 다음

WP1: (37.5675°N, 126.9790°E, 60m)
     - 대기 0초
     - 수용 반경 5m
     - Yaw -1 (방향 유지)
     - 자동 다음

WP2: (37.5685°N, 126.9800°E, 50m)
     - 착륙 명령
```

---

## 중단: 추종 알고리즘

### 기본 추종

```python
def waypoint_following(current_pos, waypoints, 
                       current_wp_idx):
    """
    웨이포인트 추종 제어
    
    Args:
        current_pos: [x, y, z] 현재 위치
        waypoints: 웨이포인트 리스트
        current_wp_idx: 현재 목표 WP 인덱스
    
    Returns:
        velocity_cmd: [vx, vy, vz] 속도 명령
        next_wp_idx: 다음 WP 인덱스
    """
    
    # ═══════════════════════════════════════
    # Step 1: 현재 목표 웨이포인트
    # ═══════════════════════════════════════
    target_wp = waypoints[current_wp_idx]
    
    # 📖 예시:
    # current_pos = [10.0, 5.0, -10.0]
    # target_wp = [30.0, 15.0, -12.0]
    
    
    # ═══════════════════════════════════════
    # Step 2: 오차 계산
    # ═══════════════════════════════════════
    error = target_wp - current_pos
    distance = np.linalg.norm(error)
    
    # 📖 예시:
    # error = [20.0, 10.0, -2.0]
    # distance = √(20² + 10² + 2²) = 22.4 m
    
    
    # ═══════════════════════════════════════
    # Step 3: 수용 반경 체크
    # ═══════════════════════════════════════
    acceptance_radius = target_wp.param2  # 예: 2.0 m
    
    if distance < acceptance_radius:
        # 웨이포인트 도달!
        print(f"WP{current_wp_idx} 도달")
        
        # 다음 웨이포인트로
        current_wp_idx += 1
        
        if current_wp_idx >= len(waypoints):
            # 미션 완료
            return np.array([0, 0, 0]), current_wp_idx
        
        # 새 목표 설정
        target_wp = waypoints[current_wp_idx]
        error = target_wp - current_pos
        distance = np.linalg.norm(error)
    
    
    # ═══════════════════════════════════════
    # Step 4: 속도 명령 계산 (P 제어)
    # ═══════════════════════════════════════
    max_speed = 5.0  # m/s
    Kp = 0.5
    
    # 비례 제어
    velocity_cmd = Kp * error
    
    # 속도 제한
    speed = np.linalg.norm(velocity_cmd)
    if speed > max_speed:
        velocity_cmd = velocity_cmd / speed * max_speed
    
    # 📖 예시:
    # velocity_cmd = 0.5 × [20, 10, -2] = [10, 5, -1]
    # speed = 11.2 > 5.0
    # velocity_cmd = [10, 5, -1] / 11.2 × 5.0
    #              = [4.46, 2.23, -0.45] m/s
    
    return velocity_cmd, current_wp_idx
```

---

### Look-ahead 추종

```python
def lookahead_following(current_pos, waypoints, 
                        current_wp_idx, lookahead_dist):
    """
    Look-ahead 추종 (더 부드러움)
    
    현재 WP와 다음 WP 사이의 
    look-ahead 거리만큼 앞선 점을 목표로
    """
    
    # 현재 → 다음 WP 벡터
    current_wp = waypoints[current_wp_idx]
    next_wp = waypoints[current_wp_idx + 1]
    
    wp_vector = next_wp - current_wp
    wp_length = np.linalg.norm(wp_vector)
    wp_direction = wp_vector / wp_length
    
    # 현재 위치에서 경로까지 수직 거리
    current_to_wp = current_pos - current_wp
    projection = np.dot(current_to_wp, wp_direction)
    
    # Look-ahead 포인트
    lookahead_point = current_wp + \
        (projection + lookahead_dist) * wp_direction
    
    # Look-ahead 포인트로 속도 명령
    error = lookahead_point - current_pos
    velocity_cmd = Kp * error
    
    # 📖 효과:
    # 부드러운 곡선
    # 오버슈트 감소
    # 고속 비행에 적합
    
    return velocity_cmd
```

---

## 하단: 실전 고려사항

```
┌────────────────────────────────────┐
│ 1. 바람 보상                        │
├────────────────────────────────────┤
│ EKF가 바람 추정                    │
│ → 속도 명령에 바람 보상 추가        │
│                                    │
│ vel_cmd = vel_base + wind_est      │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 2. 속도 프로파일                    │
├────────────────────────────────────┤
│ 시작: 가속                         │
│ 중간: 등속                         │
│ 도착: 감속                         │
│                                    │
│ S-curve 또는 trapezoidal           │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 3. Yaw 제어                         │
├────────────────────────────────────┤
│ 옵션 1: 진행 방향 (default)        │
│ 옵션 2: 고정 방향 (카메라)          │
│ 옵션 3: ROI (Region of Interest)   │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 4. Fail-safe                        │
├────────────────────────────────────┤
│ GPS 손실: 호버링 or RTL            │
│ 배터리 부족: 강제 착륙             │
│ 통신 끊김: 미션 계속 or RTL         │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"웨이포인트 추종은 생성된 경로를 실제로 비행하는 알고리즘입니다.

MAVLink 웨이포인트 구조는 순서, 명령, 대기 시간, 수용 반경, Yaw 각도, 위치(위도/경도/고도), 자동 다음 플래그를 포함합니다. 예를 들어 WP0은 대기 5초, 수용 반경 2m, Yaw 90도로 설정할 수 있습니다.

기본 추종 알고리즘을 봅시다. Step 1에서 현재 목표 웨이포인트를 가져옵니다. Step 2에서 오차와 거리를 계산합니다. 예를 들어 현재 10m, 목표 30m면 오차 20m, 거리 22.4m입니다.

Step 3에서 수용 반경 체크입니다. 거리가 수용 반경 2m 미만이면 웨이포인트 도달로 판단하고 다음 웨이포인트로 넘어갑니다. 마지막이면 미션 완료입니다.

Step 4에서 속도 명령을 P 제어로 계산합니다. Kp=0.5를 곱하고 최대 속도 5m/s로 제한합니다. 예를 들어 오차 20m면 속도 10m/s가 나오지만 5m/s로 제한됩니다.

Look-ahead 추종은 더 부드럽습니다. 현재 WP와 다음 WP 사이의 look-ahead 거리만큼 앞선 점을 목표로 합니다. 부드러운 곡선, 오버슈트 감소, 고속 비행에 적합합니다.

실전 고려사항 4가지가 있습니다. 바람 보상은 EKF 추정값을 속도 명령에 추가합니다. 속도 프로파일은 S-curve로 가속-등속-감속합니다. Yaw 제어는 진행 방향, 고정 방향, ROI 옵션이 있습니다. Fail-safe는 GPS 손실 시 호버링, 배터리 부족 시 강제 착륙을 합니다."

---
---

# 슬라이드 47: 실전 예시 - Mission Planner

## 제목
**실전 미션 계획**

## 부제목
Mission Planner / QGroundControl 사용

---

## 상단: Mission Planner 워크플로우

### Step 1: 지도 로드

```
┌────────────────────────────────────┐
│ Flight Plan 탭                      │
├────────────────────────────────────┤
│ 1. 지도 선택                        │
│    - Google Maps                   │
│    - Bing Maps                     │
│    - OpenStreetMap                 │
│                                    │
│ 2. 위치 검색                        │
│    - 주소 입력                     │
│    - GPS 좌표 입력                 │
│    - 줌 레벨 조정                  │
└────────────────────────────────────┘
```

---

### Step 2: 웨이포인트 추가

```
방법 1: 마우스 우클릭
  → "Add Waypoint"

방법 2: 자동 그리드
  → "Auto WP" → "Survey (Grid)"
  
설정:
  - 비행 고도: 50 m
  - 속도: 5 m/s
  - 카메라 각도: -90° (수직)
  - 오버랩: 70% (전후/좌우)
```

---

### Step 3: 웨이포인트 편집

```
각 WP 더블클릭 → 속성 편집

┌────────────────────────────────────┐
│ Waypoint 속성                       │
├────────────────────────────────────┤
│ Command: NAV_WAYPOINT              │
│ Lat: 37.566500°                    │
│ Lon: 126.978000°                   │
│ Alt: 50 m (AGL)                    │
│ Delay: 0 sec                       │
│ Radius: 2 m                        │
│ Yaw: -1 (auto)                     │
└────────────────────────────────────┘

특수 명령:
  - DO_SET_SERVO: 카메라 촬영
  - DO_DIGICAM_CONTROL: 사진
  - MAV_CMD_NAV_LOITER_TIME: 대기
  - MAV_CMD_NAV_LAND: 착륙
```

---

### Step 4: 업로드 및 실행

```
1. "Write WPs" 클릭
   → 드론에 업로드

2. 드론 Arming
   → Safety switch
   → RC 스틱 (Throttle down + Yaw right)

3. 비행 모드 전환
   → "Auto" 모드 선택
   
4. 실시간 모니터링
   → HUD: 고도, 속도, 자세
   → 맵: 현재 위치, 다음 WP
   → 텔레메트리: 배터리, GPS
```

---

## 중단: 자동 미션 예시

### 농업 스캔 미션

```
목적: 100m × 200m 농장 스캔

설정:
  - 고도: 50 m
  - 속도: 5 m/s
  - 카메라: 수직 (-90°)
  - 오버랩: 70%
  - 경로: Serpentine (뱀 모양)

생성된 WP: 20개
비행 시간: 8분 30초
이미지 수: 150장
```

**경로 시각화:**
```
        ↓ WP1
    ┌───┴───┐
    │       │
WP2 ├───────┤
    │       │
    ├───────┤ WP3
    │       │
    ├───────┤
    │       │
    └───────┘
        ↑ WP20 (착륙)
```

---

### 송전선 점검 미션

```
목적: 1km 송전선 점검

설정:
  - 고도: 30 m (송전선 위)
  - 속도: 3 m/s (느림)
  - 카메라: 전방 (-45°)
  - 웨이포인트: 선 따라 배치

추가 명령:
  - WP1-5: 카메라 트리거 (2초마다)
  - WP10: 호버 10초 (상세 촬영)
  - WP20: RTL (귀환)
```

---

## 하단: QGroundControl 차이점

```
┌────────────────────────────────────┐
│ Mission Planner (ArduPilot)         │
├────────────────────────────────────┤
│ ✓ 자동 그리드 생성                  │
│ ✓ 풍부한 고급 기능                 │
│ ✓ 스크립팅 (LUA)                   │
│ ✗ Windows만 (Wine으로 Linux 가능)  │
│ ✗ 복잡한 UI                        │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ QGroundControl (PX4/ArduPilot)      │
├────────────────────────────────────┤
│ ✓ 크로스 플랫폼 (Win/Mac/Linux)     │
│ ✓ 직관적 UI                        │
│ ✓ PX4 최적화                       │
│ △ 기본 기능만                      │
│ ✗ 고급 미션 계획 제한              │
└────────────────────────────────────┘

권장:
  - 초보: QGroundControl
  - 고급: Mission Planner
  - PX4: QGroundControl
  - ArduPilot: Mission Planner
```

---

## 발표 스크립트

"실전 미션 계획을 Mission Planner로 봅시다.

Step 1에서 Flight Plan 탭에서 지도를 로드합니다. Google Maps, Bing Maps, OpenStreetMap 중 선택하고 주소나 GPS 좌표로 위치를 검색합니다.

Step 2에서 웨이포인트를 추가합니다. 마우스 우클릭으로 하나씩 추가하거나, Auto WP의 Survey Grid로 자동 생성합니다. 비행 고도 50m, 속도 5m/s, 카메라 각도 -90도, 오버랩 70%로 설정합니다.

Step 3에서 각 웨이포인트를 더블클릭하여 속성을 편집합니다. 위도/경도/고도, 대기 시간, 수용 반경, Yaw를 설정합니다. DO_SET_SERVO로 카메라를 촬영하거나 MAV_CMD_NAV_LAND로 착륙할 수 있습니다.

Step 4에서 Write WPs로 드론에 업로드하고, Arming 후 Auto 모드로 전환합니다. HUD, 맵, 텔레메트리로 실시간 모니터링합니다.

농업 스캔 미션 예시입니다. 100m×200m 농장을 고도 50m, 속도 5m/s로 스캔합니다. 70% 오버랩으로 Serpentine 경로를 생성하면 20개 웨이포인트, 8분 30초, 150장 이미지가 나옵니다.

송전선 점검 미션은 1km를 고도 30m, 속도 3m/s로 비행합니다. 카메라 전방 -45도로 2초마다 트리거하고, WP10에서 10초 호버로 상세 촬영합니다.

QGroundControl은 크로스 플랫폼이고 직관적이지만 기본 기능만 제공합니다. Mission Planner는 자동 그리드와 고급 기능이 풍부하지만 Windows만 지원하고 UI가 복잡합니다. 초보는 QGC, 고급은 MP를 권장합니다."

---
---

# 슬라이드 48: 동적 장애물 회피

## 제목
**실시간 장애물 회피**

## 부제목
동적 환경에서 경로 재계획

---

## 상단: 장애물 감지 센서

```
┌────────────────────────────────────┐
│ 1. LiDAR (Light Detection & Ranging)│
├────────────────────────────────────┤
│ • 거리: 0.5 ~ 40 m                 │
│ • 주파수: 10 ~ 20 Hz               │
│ • 정확도: ±2 cm                    │
│ • 시야각: 360° (회전형)             │
│                                    │
│ 예: Velodyne VLP-16 (16 레이저)     │
│     3D 점군 생성                   │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 2. 깊이 카메라 (Depth Camera)       │
├────────────────────────────────────┤
│ • 거리: 0.2 ~ 10 m                 │
│ • 주파수: 30 ~ 90 Hz               │
│ • 해상도: 640×480                  │
│ • 시야각: 60° ~ 90°                │
│                                    │
│ 예: Intel RealSense D435i           │
│     RGB + Depth                    │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 3. 초음파 센서 (Ultrasonic)         │
├────────────────────────────────────┤
│ • 거리: 0.2 ~ 7 m                  │
│ • 주파수: 10 Hz                    │
│ • 정확도: ±1 cm                    │
│ • 시야각: 15° (좁음)               │
│                                    │
│ 예: HC-SR04 (저가)                 │
│     Pixhawk 기본 지원              │
└────────────────────────────────────┘
```

---

## 중단: 회피 알고리즘

### 1. Potential Field (포텐셜 장)

```python
def potential_field_avoidance(current_pos, goal, 
                               obstacles):
    """
    포텐셜 장 기반 회피
    
    목표: 인력 (Attractive)
    장애물: 척력 (Repulsive)
    """
    
    # ═══════════════════════════════════════
    # 인력 (목표로 끌어당김)
    # ═══════════════════════════════════════
    k_att = 1.0  # 인력 게인
    
    to_goal = goal - current_pos
    dist_to_goal = np.linalg.norm(to_goal)
    
    F_attractive = k_att * to_goal
    
    # 📖 예시:
    # to_goal = [10, 5, 0]
    # F_attractive = [10, 5, 0]
    
    
    # ═══════════════════════════════════════
    # 척력 (장애물에서 밀어냄)
    # ═══════════════════════════════════════
    k_rep = 100.0  # 척력 게인
    d_safe = 5.0   # 안전 거리
    
    F_repulsive = np.zeros(3)
    
    for obs in obstacles:
        to_obs = current_pos - obs
        dist_to_obs = np.linalg.norm(to_obs)
        
        if dist_to_obs < d_safe:
            # 가까울수록 강한 척력
            magnitude = k_rep * \
                (1.0/dist_to_obs - 1.0/d_safe) / \
                (dist_to_obs**2)
            
            F_repulsive += magnitude * \
                (to_obs / dist_to_obs)
    
    # 📖 예시:
    # 장애물 2m 거리
    # magnitude = 100 × (1/2 - 1/5) / 4 = 7.5
    # F_repulsive = [22.5, 0, 0] (X 방향)
    
    
    # ═══════════════════════════════════════
    # 총 힘 = 인력 + 척력
    # ═══════════════════════════════════════
    F_total = F_attractive + F_repulsive
    
    # 속도 명령으로 변환
    max_speed = 5.0
    velocity = F_total
    speed = np.linalg.norm(velocity)
    
    if speed > max_speed:
        velocity = velocity / speed * max_speed
    
    return velocity
```

---

### 2. DWA (Dynamic Window Approach)

```python
def dynamic_window_approach(current_pos, current_vel,
                            goal, obstacles):
    """
    동적 윈도우 접근법
    
    현재 속도 기준으로
    가능한 속도 범위 탐색
    """
    
    # ═══════════════════════════════════════
    # 동적 윈도우 (가능한 속도 범위)
    # ═══════════════════════════════════════
    max_accel = 2.0  # m/s²
    dt = 0.1         # 시간 간격
    
    # 현재 속도 기준 가속 가능 범위
    v_min = current_vel - max_accel * dt
    v_max = current_vel + max_accel * dt
    
    # 물리적 한계
    v_min = np.maximum(v_min, 0.0)
    v_max = np.minimum(v_max, 5.0)
    
    
    # ═══════════════════════════════════════
    # 후보 속도 샘플링
    # ═══════════════════════════════════════
    best_vel = current_vel
    best_score = -np.inf
    
    # 100개 속도 후보
    for vx in np.linspace(v_min[0], v_max[0], 10):
        for vy in np.linspace(v_min[1], v_max[1], 10):
            candidate_vel = np.array([vx, vy, 0])
            
            # 시뮬레이션 (1초 예측)
            predicted_pos = current_pos + \
                candidate_vel * 1.0
            
            # 충돌 체크
            collision = False
            for obs in obstacles:
                if np.linalg.norm(predicted_pos - obs) < 2.0:
                    collision = True
                    break
            
            if collision:
                continue  # 이 속도는 불가
            
            # 점수 계산
            # 1. 목표 방향 (높을수록 좋음)
            to_goal = goal - predicted_pos
            heading_score = np.dot(
                candidate_vel / np.linalg.norm(candidate_vel),
                to_goal / np.linalg.norm(to_goal)
            )
            
            # 2. 속도 (빠를수록 좋음)
            speed_score = np.linalg.norm(candidate_vel) / 5.0
            
            # 3. 장애물 거리 (멀수록 좋음)
            min_dist = min([np.linalg.norm(predicted_pos - obs)
                           for obs in obstacles])
            clearance_score = min(min_dist / 5.0, 1.0)
            
            # 총점
            total_score = 0.5 * heading_score + \
                         0.3 * speed_score + \
                         0.2 * clearance_score
            
            if total_score > best_score:
                best_score = total_score
                best_vel = candidate_vel
    
    return best_vel
```

---

## 하단: PX4 장애물 회피

### PX4 Collision Prevention

```
┌────────────────────────────────────┐
│ 설정 파라미터                       │
├────────────────────────────────────┤
│ CP_DIST = 5.0                      │
│  • 안전 거리 (m)                   │
│                                    │
│ CP_DELAY = 0.4                     │
│  • 제동 시간 (초)                  │
│                                    │
│ CP_GUIDE_ANG = 30.0                │
│  • 회피 각도 (도)                  │
│                                    │
│ MPC_COL_PREV_D = 1                 │
│  • 충돌 방지 활성화                │
└────────────────────────────────────┘

동작:
1. 센서 데이터 수신 (LiDAR/Depth)
2. 장애물 거리 계산
3. 5m 이내 장애물 감지 시
   → 해당 방향 속도 제한
4. 2m 이내 시
   → 강제 정지
```

---

## 발표 스크립트

"실시간 장애물 회피는 동적 환경에서 필수입니다.

장애물 감지 센서 3가지가 있습니다. LiDAR는 0.5~40m 거리를 10~20Hz로 측정하여 3D 점군을 생성합니다. 깊이 카메라는 0.2~10m를 30~90Hz로 RGB+Depth를 제공합니다. 초음파는 0.2~7m를 10Hz로 측정하며 저가이고 Pixhawk가 기본 지원합니다.

Potential Field 알고리즘은 목표는 인력, 장애물은 척력으로 작용합니다. 인력은 목표로 끌어당기고, 척력은 장애물에서 밀어냅니다. 가까울수록 강한 척력입니다. 총 힘은 인력+척력이고 속도 명령으로 변환합니다. 예를 들어 장애물이 2m 거리면 척력 22.5가 발생합니다.

DWA는 현재 속도 기준으로 가능한 속도 범위를 탐색합니다. 최대 가속도 2m/s²로 동적 윈도우를 계산하고, 100개 속도 후보를 샘플링합니다. 각 후보로 1초 시뮬레이션하여 충돌 체크합니다. 점수는 목표 방향 50%, 속도 30%, 장애물 거리 20%로 계산하여 최고 점수 속도를 선택합니다.

PX4 Collision Prevention은 안전 거리 5m, 제동 시간 0.4초, 회피 각도 30도로 설정합니다. 5m 이내 장애물 감지 시 해당 방향 속도를 제한하고, 2m 이내 시 강제 정지합니다."

---
---

# 슬라이드 49: 요약 및 실습 과제

## 제목
**경로 계획 요약 및 실습**

## 부제목
이론에서 실전으로

---

## 핵심 요약

### 알고리즘 분류

```
그래프 기반           샘플링 기반
(A*, Dijkstra)   vs  (RRT, PRM)
     ↓                    ↓
  완전성 ✓            확률적 완전성
  최적성 ✓            빠른 계산
  2D-3D               고차원
     ↓                    ↓
 드론에서 가장 많이 사용: A*
```

### 핵심 원리

```
✓ 최단 경로: f(n) = g(n) + h(n)
✓ 휴리스틱: 목표 방향 우선
✓ 웨이포인트 추종: P 제어 + Look-ahead
✓ 장애물 회피: Potential Field / DWA
```

---

## 실습 과제 1: A* 구현

```
┌────────────────────────────────────┐
│ 목표: A* 알고리즘 직접 구현         │
├────────────────────────────────────┤
│ 1. Python으로 2D A* 작성            │
│    • 그리드 맵 생성                │
│    • 장애물 추가                   │
│    • A* 탐색 구현                  │
│                                    │
│ 2. 시각화                          │
│    • matplotlib로 그리드 표시       │
│    • 탐색 과정 애니메이션           │
│    • 최종 경로 강조                │
│                                    │
│ 3. 휴리스틱 비교                   │
│    • 맨하탄 vs 유클리드             │
│    • 탐색 노드 수 비교              │
│                                    │
│ 4. 3D 확장 (선택)                  │
│    • 3D 그리드 맵                  │
│    • 고도 비용 추가                │
└────────────────────────────────────┘

예상 시간: 3~4시간
난이도: ★★★☆☆
```

---

## 실습 과제 2: Mission Planner 미션

```
┌────────────────────────────────────┐
│ 목표: 실제 미션 계획 및 실행        │
├────────────────────────────────────┤
│ 1. SITL 연결                       │
│    • PX4 SITL 실행                 │
│    • Mission Planner 연결          │
│                                    │
│ 2. 간단한 미션                     │
│    • 5개 웨이포인트                │
│    • 사각형 경로                   │
│    • 고도 변화 포함                │
│                                    │
│ 3. 자동 그리드 미션                │
│    • Survey (Grid) 사용            │
│    • 100m × 100m 영역              │
│    • 70% 오버랩                    │
│                                    │
│ 4. 로그 분석                       │
│    • 계획 vs 실제 경로 비교         │
│    • 웨이포인트 도달 시간           │
│    • 오차 분석                     │
└────────────────────────────────────┘

예상 시간: 2~3시간
난이도: ★★☆☆☆
```

---

## 실습 과제 3: 장애물 회피 시뮬레이션

```
┌────────────────────────────────────┐
│ 목표: 동적 회피 알고리즘 구현       │
├────────────────────────────────────┤
│ 1. Potential Field 구현             │
│    • Python 시뮬레이터              │
│    • 2D 환경                       │
│    • 정적 장애물 3개               │
│                                    │
│ 2. 시각화                          │
│    • 포텐셜 장 heatmap              │
│    • 드론 경로 애니메이션           │
│    • 힘 벡터 표시                  │
│                                    │
│ 3. 파라미터 튜닝                   │
│    • k_att 조정                    │
│    • k_rep 조정                    │
│    • d_safe 조정                   │
│    • Local minima 해결             │
│                                    │
│ 4. DWA 구현 (고급)                 │
│    • 동적 윈도우 계산              │
│    • 후보 속도 샘플링              │
│    • 점수 함수 설계                │
└────────────────────────────────────┘

예상 시간: 4~5시간
난이도: ★★★★☆
```

---

## 실습 환경

### Python A* 예제 (완성 코드는 슬라이드 44 참조)

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# 그리드 맵 생성
grid = np.zeros((20, 20))
grid[5:15, 8] = 1  # 장애물

# A* 실행
path = astar((0, 0), (19, 19), grid)

# 시각화
fig, ax = plt.subplots()
ax.imshow(grid, cmap='binary')

# 경로 그리기
if path:
    path_x = [p[1] for p in path]
    path_y = [p[0] for p in path]
    ax.plot(path_x, path_y, 'r-', linewidth=2)
    ax.plot(path_x[0], path_y[0], 'go', markersize=10)
    ax.plot(path_x[-1], path_y[-1], 'ro', markersize=10)

plt.show()
```

---

## 추가 학습 자료

```
📚 공식 문서
- PX4 Mission: https://docs.px4.io/main/en/flying/missions.html
- ArduPilot Mission Planning: https://ardupilot.org/copter/docs/common-mission-planning.html

📹 동영상
- Mission Planner Tutorial
- A* Algorithm Visualization
- RRT Path Planning

📖 논문
- "A* Search Algorithm" (Hart et al., 1968)
- "RRT: Rapidly-Exploring Random Trees" (LaValle, 1998)
- "DWA: Dynamic Window Approach" (Fox et al., 1997)

💻 코드 저장소
- PX4 Navigator: src/modules/navigator/
- ArduPilot Mission: libraries/AP_Mission/
- Python Robotics: https://github.com/AtsushiSakai/PythonRobotics
```

---

## 다음 주 예고

```
┌────────────────────────────────────┐
│ 5주차: 통신 시스템                  │
├────────────────────────────────────┤
│ • MAVLink 프로토콜 심화             │
│ • RC 통신 (SBUS, PPM)               │
│ • 텔레메트리 (900MHz, 2.4GHz)       │
│ • WiFi / LTE 통신                  │
│ • 지상 제어 프로그램 (GCS) 개발     │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"경로 계획을 정리하겠습니다. 그래프 기반은 A*와 Dijkstra로 완전성과 최적성을 보장하지만 2D-3D에 적합합니다. 샘플링 기반은 RRT와 PRM으로 확률적 완전성과 빠른 계산이 가능하지만 고차원에 적합합니다. 드론에서는 A*가 가장 많이 사용됩니다.

핵심 원리는 f(n)=g(n)+h(n)으로 최단 경로를 찾고, 휴리스틱으로 목표 방향을 우선하며, 웨이포인트 추종은 P 제어와 Look-ahead를 사용하고, 장애물 회피는 Potential Field나 DWA를 사용합니다.

실습 과제 1은 Python으로 2D A*를 구현하고 matplotlib로 시각화합니다. 맨하탄 vs 유클리드 휴리스틱을 비교하고 3D로 확장할 수 있습니다.

실습 과제 2는 Mission Planner로 실제 미션을 계획합니다. SITL에 연결하여 5개 웨이포인트 사각형 경로를 만들고, Survey Grid로 100m×100m 자동 그리드를 생성합니다. 로그에서 계획 vs 실제 경로를 비교합니다.

실습 과제 3은 Potential Field를 구현합니다. 2D 환경에 정적 장애물 3개를 만들고, 포텐셜 장 heatmap과 드론 경로를 애니메이션으로 표시합니다. k_att, k_rep, d_safe를 튜닝하고 Local minima를 해결합니다. 고급으로 DWA를 구현할 수 있습니다.

다음 주에는 통신 시스템을 배웁니다. MAVLink 프로토콜, RC 통신, 텔레메트리, WiFi/LTE 통신, GCS 개발을 알아보겠습니다."

---
---

# 🎓 부록: 발표 팁

## 시간 배분 (50분 기준)

```
슬라이드 42-43: 개요 및 분류 (10분)
슬라이드 44-45: A* 상세 (15분)
슬라이드 46-47: 웨이포인트 & 실전 (15분)
슬라이드 48: 장애물 회피 (7분)
슬라이드 49: 요약 및 실습 (3분)
```

## 강조 포인트

```
1. "왜 경로 계획이 필요한가"
   - 수동 vs 자동 비교
   - 실제 응용 사례
   - 자율 비행의 핵심

2. 알고리즘 선택
   - A*가 가장 실용적
   - 휴리스틱의 중요성
   - 실시간 재계획

3. 실전 중요성
   - Mission Planner 실습
   - 웨이포인트 설정
   - 장애물 회피
```

## 데모 제안

```
라이브 데모 (시간 허락 시):
1. Python A* 시각화
   - 탐색 과정 애니메이션
   - 휴리스틱 비교
2. Mission Planner
   - 실시간 미션 생성
   - SITL 연결 및 실행
3. Potential Field
   - 2D 시뮬레이션
   - 파라미터 조정 효과
```

---

**훌륭한 강의 되시길 바랍니다! 🚁**
