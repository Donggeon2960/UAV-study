# UAV 3주차 PPT - EKF 센서 융합 알고리즘 완전판

모든 제어의 시작점: 정확한 상태 추정

---

# 슬라이드 32: EKF 센서 융합 개요

## 제목
**알고리즘 3: EKF (Extended Kalman Filter)**

## 부제목
센서 융합으로 정확한 상태 추정

---

## 왼쪽 영역: 역할 설명

```
┌──────────────────────────────────────┐
│ 입력 (5가지 센서)                     │
├──────────────────────────────────────┤
│ • IMU:      1000 Hz (자이로+가속도)   │
│ • GPS:        10 Hz (위치)           │
│ • 기압계:     50 Hz (고도)           │
│ • 지자기:    100 Hz (방위)           │
│ • 광류:       10 Hz (속도, 선택)      │
└──────────────────────────────────────┘
           ↓
    [EKF 센서 융합]
           ↓
┌──────────────────────────────────────┐
│ 출력 (정제된 상태)                    │
├──────────────────────────────────────┤
│ • 위치:      [3.21, 1.45, -5.03] m   │
│ • 속도:      [0.85, 0.02, 0.00] m/s  │
│ • 자세:      [2.1°, -1.3°, 45.2°]    │
│ • 각속도:    [5, -2, 10] deg/s       │
│                                      │
│ 신뢰도: 위치 ±0.5m, 자세 ±1°         │
└──────────────────────────────────────┘
```

---

## 중단: 핵심 역할

### 📌 3가지 주요 기능

**1. 센서 융합 (Sensor Fusion)**
- 여러 센서 데이터를 수학적으로 결합
- 각 센서의 장점 활용, 단점 보완
- 최적 추정치 계산

**2. 노이즈 제거 (Noise Filtering)**
- 센서 측정 노이즈 제거
- 이상값(Outlier) 거부
- 부드러운(Smooth) 출력

**3. 예측 (Prediction)**
- 센서 데이터 없어도 상태 예측
- GPS 끊김 시 IMU로 단기 추정
- 제어 루프 안정성 유지

---

## 오른쪽 영역: 왜 필요한가?

### 각 센서의 한계

```
┌────────────────────────────────────┐
│ IMU (자이로 + 가속도)               │
├────────────────────────────────────┤
│ ✓ 고속 (1000 Hz)                   │
│ ✓ 저지연                           │
│ ✗ 시간에 따라 드리프트 누적         │
│ ✗ 절대 위치 모름                   │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ GPS                                │
├────────────────────────────────────┤
│ ✓ 절대 위치 정확                   │
│ ✗ 저속 (10 Hz)                     │
│ ✗ 실내/터널 불가                   │
│ ✗ 지연 ~200ms                      │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 기압계 (고도계)                     │
├────────────────────────────────────┤
│ ✓ 고도 측정                        │
│ ✗ 날씨 영향                        │
│ ✗ 상대 고도만 (절대 고도 아님)      │
└────────────────────────────────────┘

✅ EKF의 해결책:
   "고속 IMU + 정확한 GPS + 안정적 기압계"
   → 최고의 조합!
```

---

## 하단: 실행 특성

```
┌────────────────────────────────────┐
│ 예측 단계 (Prediction)              │
├────────────────────────────────────┤
│ 주파수: 200-1000 Hz                │
│ 입력: IMU만 사용                   │
│ 출력: 예측 상태                    │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 업데이트 단계 (Update)              │
├────────────────────────────────────┤
│ 주파수: 센서마다 다름               │
│   - GPS: 10 Hz                     │
│   - 기압계: 50 Hz                  │
│   - 지자기: 100 Hz                 │
│ 입력: 센서 측정값                  │
│ 출력: 보정된 상태                  │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 위치                               │
├────────────────────────────────────┤
│ PX4: src/modules/ekf2/             │
│ ArduPilot: libraries/AP_NavEKF3/   │
│                                    │
│ 상태 크기: 24개 변수               │
│ CPU 부하: ~2%                      │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"EKF는 Extended Kalman Filter의 약자로, 드론의 모든 센서 데이터를 융합하여 정확한 상태를 추정하는 알고리즘입니다. 이것은 모든 제어의 시작점입니다.

드론에는 5가지 센서가 있습니다. IMU는 1000Hz로 매우 빠르지만 시간이 지나면 드리프트가 누적됩니다. GPS는 절대 위치를 정확히 알려주지만 10Hz로 느리고 실내에서는 사용할 수 없습니다. 기압계는 고도를 측정하지만 날씨에 영향을 받습니다.

EKF는 이 센서들의 장점은 살리고 단점은 보완합니다. 고속 IMU로 단기 예측을 하고, 정확한 GPS로 장기 드리프트를 보정하며, 기압계로 고도를 안정화합니다.

출력은 위치, 속도, 자세, 각속도 등 24개 상태 변수입니다. 이것이 PID 제어기의 입력으로 들어갑니다. EKF가 없으면 제어기가 잘못된 정보를 받아 불안정한 비행이 됩니다."

---

## 이미지/다이어그램 추천

1. **센서 융합 다이어그램**: 5개 센서 → EKF → 출력
2. **시간대별 비교**: EKF 없을 때 vs 있을 때
3. **데이터 흐름**: EKF → PID → 모터

---
---

# 슬라이드 33: 센서 종류 및 특성

## 제목
**드론의 5가지 센서**

## 부제목
각 센서의 역할과 한계

---

## 1. IMU (Inertial Measurement Unit)

### 구성: 자이로 + 가속도계

```
┌────────────────────────────────────┐
│ 자이로스코프 (Gyroscope)            │
├────────────────────────────────────┤
│ 측정: 각속도 (deg/s)                │
│ 축: Roll, Pitch, Yaw               │
│ 주파수: 1000 Hz                    │
│ 노이즈: ±0.01 deg/s (ARW)          │
│                                    │
│ 예시 출력:                         │
│ [5.2, -1.3, 10.8] deg/s            │
│                                    │
│ 물리:                              │
│ • 코리올리 효과                    │
│ • MEMS 진동 구조                   │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 가속도계 (Accelerometer)            │
├────────────────────────────────────┤
│ 측정: 가속도 (m/s²)                 │
│ 축: X, Y, Z                        │
│ 주파수: 1000 Hz                    │
│ 노이즈: ±0.02 m/s² (VRW)           │
│                                    │
│ 예시 출력:                         │
│ [0.5, -0.2, -9.81] m/s²            │
│ (Z축 -9.81은 중력)                 │
│                                    │
│ 물리:                              │
│ • 스프링-질량 시스템               │
│ • 정전 용량 변화 측정              │
└────────────────────────────────────┘
```

**드리프트 문제:**
```
시간 →
각도 ────────────
    ╱
   ╱  (실제는 정지)
  ╱
 ╱ (적분 오차 누적)

1분 후: ±5° 오차
10분 후: ±50° 오차
→ GPS로 보정 필수!
```

---

## 2. GPS (Global Positioning System)

```
┌────────────────────────────────────┐
│ GPS 수신기                          │
├────────────────────────────────────┤
│ 측정: 위도, 경도, 고도              │
│ 주파수: 5-10 Hz                    │
│ 정확도: ±2.5m (일반)               │
│         ±0.3m (RTK)                │
│ 지연: ~200ms                       │
│                                    │
│ 예시 출력:                         │
│ 위도: 37.5665° N                   │
│ 경도: 126.9780° E                  │
│ 고도: 50.3 m (MSL)                 │
│                                    │
│ 위성 수: 12개 (최소 4개 필요)       │
│ HDOP: 0.8 (낮을수록 좋음)          │
└────────────────────────────────────┘

한계:
✗ 실내 불가
✗ 터널, 도심 협곡
✗ 나무/건물 아래
✗ 느린 업데이트

해결:
✓ IMU로 단기 예측
✓ 광류로 실내 위치
```

---

## 3. 기압계 (Barometer)

```
┌────────────────────────────────────┐
│ 기압 센서 (예: MS5611)              │
├────────────────────────────────────┤
│ 측정: 대기압 (hPa)                  │
│ 주파수: 50 Hz                      │
│ 정확도: ±10 cm                     │
│                                    │
│ 예시 출력:                         │
│ 압력: 1013.25 hPa                  │
│ 고도: 50.2 m (계산값)              │
│                                    │
│ 공식:                              │
│ h = 44330 × [1 - (P/P₀)^0.1903]   │
│                                    │
│ P₀: 해수면 기압 (1013.25 hPa)      │
│ P: 현재 기압                       │
└────────────────────────────────────┘

한계:
✗ 날씨 변화 (±50m 오차)
✗ 상대 고도만 측정
✗ 프로펠러 풍압 영향

해결:
✓ GPS 고도로 캘리브레이션
✓ 저역 통과 필터
```

---

## 4. 지자기계 (Magnetometer)

```
┌────────────────────────────────────┐
│ 자력계 (Compass)                    │
├────────────────────────────────────┤
│ 측정: 지구 자기장 (gauss)           │
│ 축: X, Y, Z                        │
│ 주파수: 100 Hz                     │
│ 정확도: ±2° (캘리브레이션 후)       │
│                                    │
│ 예시 출력:                         │
│ [0.2, 0.3, 0.4] gauss              │
│ 방위각: 45.2° (북쪽 기준)          │
└────────────────────────────────────┘

한계:
✗ 금속/전류 간섭
✗ 배터리, 모터, ESC
✗ 실내 왜곡

해결:
✓ 캘리브레이션 (8자 비행)
✓ GPS 방향으로 보정
```

---

## 5. 광류 센서 (Optical Flow, 선택)

```
┌────────────────────────────────────┐
│ 광류 카메라 (예: PX4Flow)           │
├────────────────────────────────────┤
│ 측정: 지면 이동 속도                │
│ 주파수: 10 Hz                      │
│ 정확도: ±0.1 m/s                   │
│ 고도 범위: 0.5 ~ 5 m               │
│                                    │
│ 예시 출력:                         │
│ 속도: [0.3, -0.1] m/s (X, Y)       │
│ 품질: 85% (지면 특징 충분)         │
└────────────────────────────────────┘

용도:
✓ GPS 없는 실내 비행
✓ 정밀 착륙
✓ 저고도 호버링
```

---

## 하단: 센서 융합 타이밍

```
시간 →  0ms   1ms   10ms  20ms  100ms

IMU     ●─●─●─●─●─●─●─●─●─●─●─●─●  (1000Hz)
기압계  ●─────●─────●─────●─────●──  (50Hz)
GPS     ●───────────────────────────  (10Hz)
지자기  ●───●───●───●───●───●───●───  (100Hz)
광류    ●───────────────────────────  (10Hz)

EKF     ●─●─●─●─●─●─●─●─●─●─●─●─●  (예측 1000Hz)
        ↑   ↑       ↑   ↑       ↑
      센서 센서    센서 센서    센서
      업뎃 업뎃    업뎃 업뎃    업뎃
```

---

## 발표 스크립트

"드론에는 5가지 센서가 있습니다.

IMU는 자이로와 가속도계로 구성됩니다. 자이로는 각속도를, 가속도계는 가속도를 1000Hz로 측정합니다. 매우 빠르지만 적분 오차가 누적되어 1분이면 5도, 10분이면 50도 오차가 생깁니다.

GPS는 절대 위치를 정확히 알려주지만 10Hz로 느리고, 200ms 지연이 있으며, 실내에서는 작동하지 않습니다.

기압계는 대기압을 측정하여 고도를 계산합니다. 50Hz로 빠르고 정확도 10cm이지만, 날씨가 변하면 50m 오차가 생기고, 프로펠러 풍압에 영향을 받습니다.

지자기계는 지구 자기장을 측정하여 방위각을 알려줍니다. 하지만 금속, 전류, 모터에서 간섭을 받아 8자 비행으로 캘리브레이션이 필요합니다.

광류 센서는 선택 사항으로, 지면을 촬영하여 이동 속도를 측정합니다. GPS 없는 실내 비행에 유용합니다.

타이밍을 보면 IMU는 1ms마다, 기압계는 20ms마다, GPS는 100ms마다 데이터를 제공합니다. EKF는 IMU 속도로 예측하고, 다른 센서가 도착하면 업데이트합니다."

---
---

# 슬라이드 34: 칼만 필터 기초

## 제목
**칼만 필터란?**

## 부제목
예측과 측정의 최적 조합

---

## 왼쪽: 기본 개념

### 2단계 프로세스

```
┌────────────────────────────────────┐
│ 1단계: 예측 (Prediction)            │
├────────────────────────────────────┤
│                                    │
│ "이전 상태 + 물리 법칙             │
│  → 현재 상태 예측"                 │
│                                    │
│ 예시:                              │
│ t=0: 위치 10m, 속도 5m/s           │
│ t=1: 위치 = 10 + 5×1 = 15m (예측)  │
│                                    │
│ ⚠️ 불확실성 증가                   │
│    (시스템 노이즈)                 │
└────────────────────────────────────┘
         ↓
┌────────────────────────────────────┐
│ 2단계: 업데이트 (Update)            │
├────────────────────────────────────┤
│                                    │
│ "예측 + 센서 측정                  │
│  → 최적 추정"                      │
│                                    │
│ 예시:                              │
│ 예측: 15m (불확실)                 │
│ 측정: 14m (GPS)                    │
│ 최적: 14.5m (가중 평균)            │
│                                    │
│ ✓ 불확실성 감소                    │
└────────────────────────────────────┘
```

---

## 중단: 수학적 표현

### 예측 단계

```
x̂(k|k-1) = F × x̂(k-1) + B × u(k)
P(k|k-1) = F × P(k-1) × F^T + Q

기호:
x̂(k|k-1): k시점 예측 상태
x̂(k-1):   이전 추정 상태
F:        상태 전이 행렬
B:        제어 입력 행렬
u(k):     제어 입력 (모터 명령)
P:        오차 공분산 행렬
Q:        프로세스 노이즈
```

**예시:**
```
상태: [위치, 속도]^T

F = [1  dt]   (dt = 0.001s)
    [0   1]

x̂(k-1) = [10]  m
          [ 5]  m/s

x̂(k|k-1) = [1  0.001] × [10]
            [0    1  ]   [ 5]
          = [10.005]
            [ 5.000]
```

---

### 업데이트 단계

```
K = P(k|k-1) × H^T × [H × P(k|k-1) × H^T + R]^(-1)
x̂(k|k) = x̂(k|k-1) + K × [z(k) - H × x̂(k|k-1)]
P(k|k) = (I - K × H) × P(k|k-1)

기호:
K:       칼만 게인 (가중치)
H:       측정 행렬
z(k):    센서 측정값
R:       측정 노이즈
```

**칼만 게인의 의미:**
```
K = 0: 측정 무시 (예측만 신뢰)
K = 1: 예측 무시 (측정만 신뢰)
K = 0.5: 둘다 50% 신뢰
```

---

## 오른쪽: 시각적 이해

### 가우시안 분포

```
예측 (넓은 분포 = 불확실)
        ╱╲
       ╱  ╲
      ╱    ╲
     ╱      ╲
    ╱        ╲
───┴──────────┴────
  10     15     20  (m)

측정 (좁은 분포 = 확실)
          ╱╲
         ╱  ╲
        ╱    ╲
───────┴──────┴─────
      13  14  15  (m)

융합 (중간 분포)
        ╱╲
       ╱  ╲
      ╱    ╲
─────┴──────┴───────
    13 14.5 16  (m)

최적 추정 = 14.5m
```

---

## 하단: 왜 "최적"인가?

```
┌────────────────────────────────────┐
│ 수학적 증명 (최소 제곱)             │
├────────────────────────────────────┤
│ 칼만 필터는 평균 제곱 오차(MSE)를   │
│ 최소화하는 유일한 선형 필터         │
│                                    │
│ min E[(x - x̂)^2]                   │
│                                    │
│ 조건:                              │
│ • 선형 시스템                      │
│ • 가우시안 노이즈                  │
│ • 노이즈 공분산 알려짐              │
└────────────────────────────────────┘

✅ 장점:
  • 재귀적 (과거 데이터 저장 불필요)
  • 실시간 처리 가능
  • 계산 효율적

❌ 한계:
  • 비선형 시스템 부정확
    → EKF로 해결!
```

---

## 발표 스크립트

"칼만 필터는 예측과 측정을 최적으로 조합하는 알고리즘입니다. 2단계로 작동합니다.

1단계 예측에서는 이전 상태와 물리 법칙으로 현재 상태를 예측합니다. 예를 들어 t=0에서 위치 10m, 속도 5m/s였다면, t=1에서 위치는 15m일 것으로 예측합니다. 하지만 이 예측은 불확실합니다.

2단계 업데이트에서는 센서 측정값을 받습니다. GPS가 14m를 측정했다면, 예측 15m와 측정 14m을 조합하여 최적 추정치 14.5m를 계산합니다.

핵심은 칼만 게인 K입니다. 이것이 0이면 측정을 무시하고, 1이면 예측을 무시합니다. 보통 0.5 근처로, 둘 다 적절히 신뢰합니다.

가우시안 분포로 보면, 예측은 넓은 분포(불확실), 측정은 좁은 분포(확실)입니다. 융합하면 중간 분포가 되어 불확실성이 감소합니다.

칼만 필터가 '최적'인 이유는 수학적으로 평균 제곱 오차를 최소화하는 유일한 선형 필터이기 때문입니다. 재귀적이라 과거 데이터 저장이 필요 없고, 실시간 처리가 가능합니다."

---
---

# 슬라이드 35: EKF - 비선형 확장

## 제목
**Extended Kalman Filter (EKF)**

## 부제목
비선형 시스템을 위한 칼만 필터

---

## 상단: 왜 EKF가 필요한가?

### 드론은 비선형 시스템

```
┌────────────────────────────────────┐
│ 선형 시스템 (기본 칼만 필터)        │
├────────────────────────────────────┤
│ x(k) = F × x(k-1) + B × u          │
│                                    │
│ 예시: 1차원 등속 운동              │
│ pos(k) = pos(k-1) + vel × dt       │
│                                    │
│ ✓ 간단한 행렬 곱셈                 │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 비선형 시스템 (드론)                │
├────────────────────────────────────┤
│ x(k) = f(x(k-1), u)                │
│                                    │
│ 예시: 쿼터니언 회전                │
│ q(k) = q(k-1) ⊗ δq                │
│ (⊗는 비선형 쿼터니언 곱)            │
│                                    │
│ ✗ 행렬 곱셈으로 표현 불가           │
│ → 선형화 필요!                     │
└────────────────────────────────────┘
```

---

## 중단: EKF의 핵심 아이디어

### 국소 선형화 (Linearization)

```
비선형 함수 f(x):

     f(x)
      │    ╱
      │  ╱
      │╱  ← 곡선 (비선형)
  ────┼────────
      │ ╲
      │  ╲
      │   ╲

EKF 근사:

     f(x)
      │
      │  ╱─── ← 접선 (선형 근사)
      │╱
  ────┼────────
      x̂
    (현재 추정)

접선 = 자코비안 행렬 (Jacobian)
```

---

## 하단: EKF 수식

### 예측 단계

```
x̂(k|k-1) = f(x̂(k-1), u(k))  ← 비선형 함수 직접 사용

F = ∂f/∂x |x̂(k-1)  ← 자코비안 계산

P(k|k-1) = F × P(k-1) × F^T + Q  ← 선형화된 F 사용
```

**예시: 2D 회전**
```
f(x, y, θ) = [x + v×cos(θ)×dt]
             [y + v×sin(θ)×dt]
             [θ + ω×dt      ]

자코비안:
F = [1  0  -v×sin(θ)×dt]
    [0  1   v×cos(θ)×dt]
    [0  0        1     ]
```

---

### 업데이트 단계

```
z_pred = h(x̂(k|k-1))  ← 비선형 측정 모델

H = ∂h/∂x |x̂(k|k-1)  ← 자코비안 계산

K = P(k|k-1) × H^T × [H × P(k|k-1) × H^T + R]^(-1)

x̂(k|k) = x̂(k|k-1) + K × [z(k) - z_pred]

P(k|k) = (I - K × H) × P(k|k-1)
```

**예시: GPS 측정**
```
h(x, y, z) = [lat(x,y)]  ← 비선형 좌표 변환
             [lon(x,y)]
             [alt(z) ]

자코비안 H는 현재 위치에서 편미분으로 계산
```

---

## 오른쪽: EKF vs 기본 KF

```
┌────────────────────────────────────┐
│ 기본 칼만 필터 (KF)                 │
├────────────────────────────────────┤
│ ✓ 선형 시스템                      │
│ ✓ 최적 (MSE 최소)                  │
│ ✓ 간단한 계산                      │
│ ✗ 드론에 부적합                    │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ Extended 칼만 필터 (EKF)            │
├────────────────────────────────────┤
│ ✓ 비선형 시스템                    │
│ △ 근사 최적 (국소)                 │
│ ✗ 자코비안 계산 필요               │
│ ✓ 드론에 적합                      │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ Unscented KF (UKF) (고급)           │
├────────────────────────────────────┤
│ ✓ 비선형 시스템                    │
│ ✓ EKF보다 정확                     │
│ ✗ 계산 비용 2~3배                  │
│ △ 일부 고급 드론 사용              │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"기본 칼만 필터는 선형 시스템만 다룰 수 있습니다. 하지만 드론은 비선형 시스템입니다. 예를 들어 쿼터니언 회전은 비선형 곱셈이라 행렬로 표현할 수 없습니다.

EKF의 핵심 아이디어는 국소 선형화입니다. 비선형 함수를 곡선으로 보고, 현재 추정치 근처에서 접선을 그어 선형 근사합니다. 이 접선이 바로 자코비안 행렬입니다.

예측 단계에서는 비선형 함수 f를 직접 사용하지만, 오차 공분산 P는 자코비안으로 선형화하여 계산합니다. 업데이트 단계도 마찬가지입니다.

예를 들어 2D 회전의 자코비안을 보면, 각도 θ에 대한 편미분이 -v×sin(θ)×dt, v×cos(θ)×dt로 나타납니다. 이것이 θ 근처에서의 선형 근사입니다.

기본 KF는 선형이라 최적이지만 드론에 부적합하고, EKF는 근사 최적이지만 드론에 적합합니다. UKF는 더 정확하지만 계산 비용이 2~3배라 일부 고급 드론만 사용합니다. PX4는 EKF2를 표준으로 사용합니다."

---
---

# 슬라이드 36: 24-상태 추정기

## 제목
**PX4 EKF2의 24개 상태 변수**

## 부제목
무엇을 추정하는가?

---

## 24개 상태 변수

```
┌────────────────────────────────────┐
│ 1-4: 쿼터니언 자세 (q0, q1, q2, q3)│
├────────────────────────────────────┤
│ • 롤, 피치, 요 → 4D 표현            │
│ • Gimbal Lock 방지                 │
│ • 정규화: ||q|| = 1                │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 5-7: 속도 (vx, vy, vz)             │
├────────────────────────────────────┤
│ • NED 좌표계 (m/s)                 │
│ • North, East, Down                │
│ • GPS + IMU 융합                   │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 8-10: 위치 (px, py, pz)            │
├────────────────────────────────────┤
│ • NED 좌표계 (m)                   │
│ • 원점: 이륙 지점                  │
│ • GPS + 기압계 융합                │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 11-13: 자이로 바이어스 (bgx,by,bz) │
├────────────────────────────────────┤
│ • 자이로 영점 오차 (deg/s)         │
│ • 온도 변화로 드리프트              │
│ • 실시간 추정 및 보정               │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 14-16: 가속도 바이어스 (bax,by,bz) │
├────────────────────────────────────┤
│ • 가속도계 영점 오차 (m/s²)        │
│ • 중력 방향 정렬 오차               │
│ • 드론 CG 오프셋 보정               │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 17-19: 지구 자기장 (magx, y, z)     │
├────────────────────────────────────┤
│ • NED 좌표계 (gauss)               │
│ • 위치마다 다름 (위도/경도)         │
│ • 초기화 시 학습                   │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 20-22: 기체 자기장 (magbx, by, bz)  │
├────────────────────────────────────┤
│ • 모터/배터리 간섭 (gauss)          │
│ • 각 드론마다 고유                 │
│ • 캘리브레이션으로 추정             │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 23-24: 바람 (windx, windy)          │
├────────────────────────────────────┤
│ • 수평 바람 속도 (m/s)             │
│ • GPS-IMU 차이로 추정              │
│ • 제어 보상에 사용                 │
└────────────────────────────────────┘
```

---

## 오른쪽: 상태 그룹화

### 핵심 상태 (10개)

```
자세 + 속도 + 위치
= 쿼터니언(4) + 속도(3) + 위치(3)

이것만 있어도 기본 비행 가능
```

### 바이어스 (6개)

```
자이로(3) + 가속도(3)

센서 오차 실시간 보정
→ 드리프트 방지
```

### 자기장 (6개)

```
지구(3) + 기체(3)

방위각 정확도 향상
→ Yaw 드리프트 방지
```

### 환경 (2개)

```
바람(2)

외란 추정 및 보상
→ 위치 제어 향상
```

---

## 하단: 상태 업데이트 주기

```
┌────────────────────────────────────┐
│ 예측 (모든 상태)                    │
├────────────────────────────────────┤
│ 주파수: 200-1000 Hz (IMU 속도)     │
│ 입력: IMU (자이로 + 가속도)         │
│                                    │
│ 모든 24개 상태를 매 루프마다 예측   │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 업데이트 (선택적 상태)              │
├────────────────────────────────────┤
│ GPS (10 Hz):                       │
│  → 위치(3) + 속도(3) + 바람(2)      │
│                                    │
│ 기압계 (50 Hz):                    │
│  → 위치-Z(1)                       │
│                                    │
│ 지자기 (100 Hz):                   │
│  → 자세-Yaw(1) + 자기장(6)         │
│                                    │
│ 광류 (10 Hz):                      │
│  → 속도-XY(2)                      │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"PX4 EKF2는 24개의 상태 변수를 추정합니다.

먼저 쿼터니언 자세 4개는 롤, 피치, 요를 Gimbal Lock 없이 표현합니다. 속도 3개와 위치 3개는 NED 좌표계에서 드론의 움직임을 나타냅니다.

자이로 바이어스 3개와 가속도 바이어스 3개는 센서의 영점 오차를 실시간으로 추정하여 드리프트를 방지합니다. 온도가 변하면 센서 출력이 달라지는데, 이를 자동으로 보정합니다.

지구 자기장 3개는 위치마다 다른 지구 자기장을 학습하고, 기체 자기장 3개는 모터와 배터리가 만드는 간섭을 추정합니다. 이것으로 방위각 정확도가 크게 향상됩니다.

바람 2개는 수평 바람 속도를 추정합니다. GPS와 IMU 차이로 바람을 역산하여 제어 보상에 사용합니다.

10개 핵심 상태만 있어도 기본 비행은 가능하지만, 나머지 14개가 있어야 장시간 정확한 비행이 가능합니다.

예측은 IMU 속도로 모든 24개 상태를 매번 계산하고, 업데이트는 센서마다 관련 상태만 선택적으로 보정합니다."

---
---

# 슬라이드 37: 예측 단계 (Prediction)

## 제목
**EKF 예측 단계**

## 부제목
IMU로 상태 전파

---

## 상단: 역할

```
┌────────────────────────────────────┐
│ 예측의 목적                         │
├────────────────────────────────────┤
│ 1. 센서 없어도 상태 추정            │
│    → GPS 10Hz인데 제어는 1000Hz     │
│    → 중간 90%는 예측으로 채움       │
│                                    │
│ 2. 다음 측정 대비                  │
│    → 센서 오면 비교할 기준          │
│                                    │
│ 3. 불확실성 전파                   │
│    → 시간 지날수록 불확실성 증가    │
└────────────────────────────────────┘
```

---

## 중단: 완전한 코드

```cpp
void Ekf::predictState()
{
    // ═══════════════════════════════════════
    // Step 1: IMU 데이터 읽기
    // ═══════════════════════════════════════
    Vector3f gyro = _imu_sample.gyro;      // rad/s
    Vector3f accel = _imu_sample.accel;    // m/s²
    float dt = _imu_sample.dt;             // 0.001s (1000Hz)
    
    // 📖 예시:
    // gyro = [0.05, -0.02, 0.10] rad/s
    // accel = [0.5, -0.2, -9.81] m/s²
    
    
    // ═══════════════════════════════════════
    // Step 2: 바이어스 제거
    // ═══════════════════════════════════════
    gyro -= _state.gyro_bias;
    accel -= _state.accel_bias;
    
    // 📖 예시:
    // gyro_bias = [0.001, 0.000, -0.002]
    // gyro_corrected = [0.049, -0.020, 0.102]
    
    
    // ═══════════════════════════════════════
    // Step 3: 쿼터니언 업데이트
    // ═══════════════════════════════════════
    // 각속도 → 쿼터니언 미분
    Vector3f omega = gyro * 0.5f;
    Quatf dq(0.0f, omega(0)*dt, omega(1)*dt, omega(2)*dt);
    
    // 쿼터니언 적분
    _state.quat = _state.quat * dq;
    _state.quat.normalize();  // ||q|| = 1 유지
    
    // 📖 예시:
    // dq = [0, 0.0000245, -0.00001, 0.000051]
    // 새 자세 = 이전 자세 ⊗ dq (비선형 곱)
    
    
    // ═══════════════════════════════════════
    // Step 4: 속도 업데이트
    // ═══════════════════════════════════════
    // 가속도를 월드 좌표계로 변환
    Vector3f accel_world = 
        _state.quat.rotateVector(accel);
    
    // 중력 제거
    accel_world(2) += GRAVITY;  // +9.81 m/s²
    
    // 속도 적분
    _state.vel += accel_world * dt;
    
    // 📖 예시:
    // accel_body = [0.5, -0.2, -9.81]
    // accel_world = [0.52, -0.18, 0.03] (회전 후)
    // accel_world = [0.52, -0.18, 0.03 + 9.81]
    //             = [0.52, -0.18, 9.84]
    // 중력 제거 후 = [0.52, -0.18, 0.03] m/s²
    // vel += [0.52, -0.18, 0.03] × 0.001
    //      = [0.00052, -0.00018, 0.00003] m/s
    
    
    // ═══════════════════════════════════════
    // Step 5: 위치 업데이트
    // ═══════════════════════════════════════
    _state.pos += _state.vel * dt;
    
    // 📖 예시:
    // vel = [2.5, 0.3, 0.0] m/s
    // pos += [2.5, 0.3, 0.0] × 0.001
    //      = [0.0025, 0.0003, 0.0] m
    
    
    // ═══════════════════════════════════════
    // Step 6: 오차 공분산 예측 (P)
    // ═══════════════════════════════════════
    // 자코비안 행렬 F 계산
    Matrix24f F = calcStateTransitionMatrix(gyro, accel, dt);
    
    // P = F × P × F^T + Q
    _P = F * _P * F.transpose() + _Q;
    
    // 📖 의미:
    // 시간이 지날수록 불확실성(P) 증가
    // 프로세스 노이즈(Q)만큼 증가
    
    // 🔍 예시:
    // 위치 불확실성:
    // t=0:    ±0.1m
    // t=0.1s: ±0.5m (예측만 10번)
    // t=1.0s: ±5.0m (GPS 없으면 발산!)
}
```

---

## 하단: 자코비안 계산

```cpp
Matrix24f Ekf::calcStateTransitionMatrix(
    const Vector3f &gyro,
    const Vector3f &accel,
    float dt)
{
    Matrix24f F = Matrix24f::Identity();
    
    // 자세 → 속도 연결
    // ∂vel/∂quat = 회전 행렬 미분
    Matrix3f R = quat_to_rotmat(_state.quat);
    Matrix3f dR_dq = calc_rotation_jacobian(accel);
    F.block<3,4>(4, 0) = dR_dq * dt;
    
    // 속도 → 위치 연결
    // ∂pos/∂vel = I × dt
    F.block<3,3>(7, 4) = Matrix3f::Identity() * dt;
    
    // 자이로 바이어스 → 자세 연결
    // ∂quat/∂gyro_bias
    F.block<4,3>(0, 10) = -0.5f * dt * 
        quat_to_skew_symmetric(_state.quat);
    
    return F;
}
```

---

## 발표 스크립트

"예측 단계는 IMU 속도로 실행됩니다. GPS가 10Hz인데 제어는 1000Hz라 중간 90%는 예측으로 채워야 합니다.

Step 1에서 자이로와 가속도계 데이터를 읽습니다. dt는 0.001초, 즉 1ms입니다.

Step 2에서 바이어스를 제거합니다. 센서에는 영점 오차가 있어서 정지 상태에서도 0이 아닙니다. 이전에 추정한 바이어스를 빼서 보정합니다.

Step 3에서 쿼터니언을 업데이트합니다. 각속도를 쿼터니언 미분으로 변환하고 적분합니다. 반드시 정규화하여 크기 1을 유지해야 합니다.

Step 4에서 속도를 업데이트합니다. 가속도를 월드 좌표계로 회전하고 중력을 제거한 후 적분합니다. 예를 들어 Z축 -9.81이 측정되면, 이것은 중력이므로 +9.81을 더해 상쇄합니다.

Step 5에서 위치를 업데이트합니다. 속도를 적분하면 위치 변화량입니다.

Step 6에서 오차 공분산 P를 예측합니다. 자코비안 행렬 F를 계산하고 P = F×P×F^T + Q 공식을 적용합니다. 시간이 지날수록 불확실성이 증가합니다. 0.1초만 지나도 위치 불확실성이 ±0.1m에서 ±0.5m로 증가하고, 1초면 ±5m까지 발산합니다. GPS 업데이트가 필수인 이유입니다."

---
---

# 슬라이드 38: 업데이트 단계 (Update)

## 제목
**EKF 업데이트 단계**

## 부제목
센서로 예측 보정

---

## 상단: GPS 업데이트 예시

```cpp
void Ekf::fuseGPS()
{
    // ═══════════════════════════════════════
    // Step 1: GPS 데이터 받기
    // ═══════════════════════════════════════
    Vector3f gps_pos = _gps_sample.pos;  // [m]
    Vector3f gps_vel = _gps_sample.vel;  // [m/s]
    
    // 📖 예시:
    // gps_pos = [10.5, 5.2, -50.3] m
    // gps_vel = [2.3, 0.1, -0.05] m/s
    
    
    // ═══════════════════════════════════════
    // Step 2: 예측값 계산
    // ═══════════════════════════════════════
    Vector3f pos_pred = _state.pos;
    Vector3f vel_pred = _state.vel;
    
    // 📖 예시:
    // pos_pred = [12.0, 4.8, -49.8] m (예측)
    
    
    // ═══════════════════════════════════════
    // Step 3: Innovation (잔차)
    // ═══════════════════════════════════════
    Vector3f innov_pos = gps_pos - pos_pred;
    Vector3f innov_vel = gps_vel - vel_pred;
    
    // 📖 예시:
    // innov_pos = [10.5, 5.2, -50.3] - [12.0, 4.8, -49.8]
    //           = [-1.5, 0.4, -0.5] m
    //
    // 🔍 의미:
    // GPS는 예측보다 1.5m 서쪽에 있다고 말함
    
    
    // ═══════════════════════════════════════
    // Step 4: 측정 행렬 H
    // ═══════════════════════════════════════
    // GPS는 위치(8-10)와 속도(5-7)만 측정
    MatrixXf H = MatrixXf::Zero(6, 24);
    
    // 위치 측정
    H(0, 7) = 1.0f;  // GPS-X → 상태-X
    H(1, 8) = 1.0f;  // GPS-Y → 상태-Y
    H(2, 9) = 1.0f;  // GPS-Z → 상태-Z
    
    // 속도 측정
    H(3, 4) = 1.0f;  // GPS-vX → 상태-vX
    H(4, 5) = 1.0f;  // GPS-vY → 상태-vY
    H(5, 6) = 1.0f;  // GPS-vZ → 상태-vZ
    
    
    // ═══════════════════════════════════════
    // Step 5: 칼만 게인 K
    // ═══════════════════════════════════════
    // Innovation 공분산
    MatrixXf S = H * _P * H.transpose() + _R_gps;
    
    // 칼만 게인
    MatrixXf K = _P * H.transpose() * S.inverse();
    
    // 📖 예시:
    // K_pos ≈ 0.7 (예측 30% + 측정 70%)
    // 이유: GPS가 예측보다 정확
    
    
    // ═══════════════════════════════════════
    // Step 6: 상태 보정
    // ═══════════════════════════════════════
    VectorXf innovation(6);
    innovation << innov_pos, innov_vel;
    
    VectorXf correction = K * innovation;
    
    // 각 상태 업데이트
    _state.pos += correction.segment<3>(7);
    _state.vel += correction.segment<3>(4);
    
    // 📖 예시:
    // 보정 = 0.7 × [-1.5, 0.4, -0.5]
    //      = [-1.05, 0.28, -0.35] m
    //
    // 최종 위치 = 12.0 + (-1.05) = 10.95 m
    // (GPS 10.5와 예측 12.0의 중간)
    
    
    // ═══════════════════════════════════════
    // Step 7: 오차 공분산 업데이트
    // ═══════════════════════════════════════
    Matrix24f I_KH = Matrix24f::Identity() - K * H;
    _P = I_KH * _P * I_KH.transpose() + 
         K * _R_gps * K.transpose();
    
    // 📖 의미:
    // 불확실성(P) 감소!
    // 측정 후: ±0.5m → ±0.1m
}
```

---

## 중단: Innovation Gate

### 이상값 거부

```cpp
// Innovation이 너무 크면 거부
float innov_norm = innov_pos.norm();
float gate_size = 5.0f * sqrt(S.trace());

if (innov_norm > gate_size) {
    // 이상값 (Outlier) 감지!
    // GPS 오류 또는 예측 크게 벗어남
    return;  // 업데이트 안 함
}

// 📖 예시:
// innov_norm = 1.6m (정상)
// gate_size = 3.0m (5σ)
// → 통과, 업데이트 수행

// innov_norm = 50m (이상!)
// → 거부, GPS 무시
```

---

## 하단: 센서별 업데이트 주기

```
GPS 업데이트 (10 Hz):
t=0.0  ●────────────────────────────
t=0.1            ●──────────────────
t=0.2                      ●────────
      ↑          ↑         ↑
    위치+속도  위치+속도  위치+속도
    (6개 상태) (6개 상태) (6개 상태)

기압계 업데이트 (50 Hz):
t=0.00 ●────●────●────●────●────●───
t=0.02      ●    ●    ●    ●    ●
       ↑    ↑    ↑    ↑    ↑    ↑
      고도  고도  고도  고도  고도  고도
    (1개 상태)

지자기 업데이트 (100 Hz):
t=0.00 ●─●─●─●─●─●─●─●─●─●─●─●─●─●
       ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑
      Yaw  Yaw  Yaw...
    (1개 상태 + 자기장 6개)

예측 (1000 Hz):
●─●─●─●─●─●─●─●─●─●─●─●─●─●─●─●─●─●
모든 24개 상태 매번 예측
```

---

## 발표 스크립트

"업데이트 단계는 센서가 도착할 때마다 실행됩니다. GPS 업데이트를 예시로 봅시다.

Step 1에서 GPS 데이터를 받습니다. 위치 [10.5, 5.2, -50.3]m와 속도 [2.3, 0.1, -0.05] m/s입니다.

Step 2에서 현재 예측값은 [12.0, 4.8, -49.8]m입니다.

Step 3에서 Innovation, 즉 잔차를 계산합니다. GPS - 예측 = [-1.5, 0.4, -0.5]m입니다. GPS는 예측보다 1.5m 서쪽에 있다고 말합니다.

Step 4에서 측정 행렬 H를 만듭니다. GPS는 24개 상태 중 위치 3개와 속도 3개, 총 6개만 측정하므로 6×24 행렬이고 대부분 0입니다.

Step 5에서 칼만 게인 K를 계산합니다. K≈0.7이 나왔다면, 예측 30%, 측정 70%를 신뢰한다는 의미입니다. GPS가 예측보다 정확하기 때문입니다.

Step 6에서 상태를 보정합니다. 보정량 = 0.7 × (-1.5) = -1.05m입니다. 최종 위치는 12.0 - 1.05 = 10.95m로, GPS 10.5와 예측 12.0의 중간입니다.

Step 7에서 오차 공분산 P를 업데이트합니다. 측정 후 불확실성이 ±0.5m에서 ±0.1m로 감소합니다.

Innovation Gate는 이상값을 거부합니다. Innovation이 50m처럼 비정상적으로 크면 GPS 오류로 판단하고 업데이트를 안 합니다."

---
---

# 슬라이드 39: 실전 예시 - GPS 끊김

## 제목
**실전 시나리오: GPS 끊김 시 EKF 동작**

## 부제목
예측만으로 버티기

---

## 시나리오: 터널 진입

```
드론이 GPS를 사용하여 비행 중,
갑자기 터널에 진입하여 GPS 신호 끊김
```

---

## 타임라인

### t = 0.0s: 정상 비행

```
┌──────────────────────────────────────┐
│ 센서 상태                             │
├──────────────────────────────────────┤
│ GPS:     [100.0, 50.0, -10.0] m      │
│ IMU:     정상 작동                   │
│ 불확실성: ±0.1m                      │
└──────────────────────────────────────┘

EKF 동작:
• 예측 (IMU): 1000 Hz
• 업데이트 (GPS): 10 Hz
• 위치 정확도: ±10 cm

그래프:
위치 ─────────────
     (안정적)
```

---

### t = 1.0s: GPS 끊김

```
┌──────────────────────────────────────┐
│ 상태 변화                             │
├──────────────────────────────────────┤
│ GPS:     신호 없음 ✗                 │
│ IMU:     정상 작동 ✓                 │
│ 모드:    GPS → IMU-only              │
└──────────────────────────────────────┘

EKF 동작:
• 예측만 실행 (IMU)
• GPS 업데이트 없음
• 불확실성 급증 시작

⚠️ 경고:
"GPS lost, switching to dead reckoning"
```

---

### t = 1.0 ~ 5.0s: IMU-only 항법

```
┌──────────────────────────────────────┐
│ EKF 예측만 실행                       │
├──────────────────────────────────────┤
│ t=1s: 위치 ±0.1m → ±0.5m            │
│ t=2s: ±0.5m → ±2.0m                 │
│ t=3s: ±2.0m → ±5.0m                 │
│ t=4s: ±5.0m → ±10.0m                │
│ t=5s: ±10.0m → ±20.0m               │
└──────────────────────────────────────┘

그래프:
위치 ─────╱
        ╱ (드리프트)
       ╱

불확실성 ╱╱╱╱╱
        ╱ (급증)
       ╱

물리적 효과:
• 자이로 바이어스 누적
• 가속도 적분 오차
• 위치 드리프트
```

---

### t = 5.0s: 비상 대응

```
┌──────────────────────────────────────┐
│ PX4 Fail-safe 발동                    │
├──────────────────────────────────────┤
│ 불확실성 > 10m                       │
│ → 자동 착륙 모드                     │
│                                      │
│ 또는                                 │
│                                      │
│ RC 제어로 전환                       │
│ (조종사 수동 조작)                   │
└──────────────────────────────────────┘

```

---

### t = 8.0s: GPS 복구

```
┌──────────────────────────────────────┐
│ GPS 신호 재획득                       │
├──────────────────────────────────────┤
│ 위치 점프 발생 가능                  │
│                                      │
│ 예측: [150, 60, -10] m (IMU 누적)    │
│ GPS:  [145, 58, -10] m (실제)        │
│ Innovation: [-5, -2, 0] m (큼!)      │
└──────────────────────────────────────┘

EKF 동작:
1. Innovation Gate 체크
   → 5m < 10m (통과)
   
2. 큰 보정 적용
   → 위치 점프 5m
   
3. 불확실성 급감
   → ±20m → ±0.5m
   
4. 정상 모드 복귀

⚠️ 위치 점프로 드론 흔들림 발생
   (제어기가 큰 오차 보고 급격히 반응)
```

---

## 그래프 비교

```
위치 오차 (m)
20 ┤              ╱╲
15 ┤            ╱  ╲
10 ┤          ╱    ╲
5  ┤        ╱      ╲
0  ┼────────        ────────
   0  1  2  3  4  5  6  7  8  [s]
      ↑           ↑        ↑
    GPS         Fail     GPS
    끊김        -safe    복구

불확실성 (m)
20 ┤              ╱╲
15 ┤            ╱  ╰╮
10 ┤          ╱     ╰╮
5  ┤        ╱        ╰╮
0  ┼────────           ╰─────
   0  1  2  3  4  5  6  7  8  [s]
```

---

## 교훈

```
✅ EKF의 강점:
• 단기 GPS 끊김 버팀 (5초 이내)
• IMU로 연속 추정
• 자동 모드 전환

❌ EKF의 한계:
• 장기 GPS 없으면 발산
• 5초 후 ±20m 오차
• 위치 점프 가능

✓ 해결책:
• 광류 센서 추가 (실내)
• UWB 비콘 (실내 위치)
• 사전 지도 (Visual SLAM)
```

---

## 발표 스크립트

"실전 예시로 GPS 끊김 상황을 봅시다. 드론이 정상 비행 중 터널에 진입하여 GPS 신호가 끊깁니다.

t=0에서는 GPS와 IMU 모두 정상이고 위치 정확도 ±10cm입니다.

t=1초에 GPS가 끊기면 EKF는 IMU-only 모드로 전환합니다. 예측만 실행하고 GPS 업데이트는 없습니다.

t=1~5초 동안 불확실성이 급증합니다. 1초 후 ±0.5m, 2초 후 ±2m, 5초 후 ±20m까지 증가합니다. 자이로 바이어스와 가속도 적분 오차가 누적되어 위치 드리프트가 발생합니다.

t=5초에 불확실성이 10m를 초과하면 PX4 Fail-safe가 발동하여 자동 착륙하거나 RC 제어로 전환합니다.

t=8초에 GPS가 복구되면 큰 Innovation이 발생합니다. 예측은 150m인데 GPS는 145m를 보고합니다. 5m 차이입니다. Innovation Gate를 통과하면 큰 보정을 적용하여 위치가 5m 점프합니다. 이때 드론이 흔들릴 수 있습니다.

그래프를 보면 GPS 끊김 후 위치 오차와 불확실성이 급증하다가 GPS 복구 시 급감하는 것을 볼 수 있습니다.

EKF의 강점은 단기 GPS 끊김을 버틸 수 있다는 것이고, 한계는 5초 후 ±20m 오차로 발산한다는 것입니다. 해결책은 실내에서 광류 센서나 UWB 비콘을 추가하는 것입니다."

---
---

# 슬라이드 40: EKF 튜닝 파라미터

## 제목
**EKF 튜닝 가이드**

## 부제목
센서 노이즈와 게이트 설정

---

## 왼쪽: 프로세스 노이즈 (Q)

### 시스템 모델 불확실성

```
┌────────────────────────────────────┐
│ PX4 파라미터: EKF2_*_NOISE          │
├────────────────────────────────────┤
│ EKF2_ACC_NOISE = 0.35               │
│  • 가속도계 노이즈 (m/s²)           │
│  • 높을수록: 가속도 덜 신뢰         │
│  • 낮을수록: 빠른 응답, 떨림        │
│                                    │
│ EKF2_GYR_NOISE = 0.015              │
│  • 자이로 노이즈 (rad/s)            │
│  • 높을수록: 각속도 덜 신뢰         │
│  • 낮을수록: 빠른 자세 추적         │
│                                    │
│ EKF2_GYR_B_NOISE = 0.001            │
│  • 자이로 바이어스 노이즈           │
│  • 바이어스 변화율                 │
│  • 온도 안정: 낮게 (0.0001)        │
│  • 온도 불안정: 높게 (0.01)        │
└────────────────────────────────────┘

조정 방법:
1. 기본값으로 시작
2. 로그에서 Innovation 확인
3. Innovation이 크면: 노이즈 증가
4. 응답이 느리면: 노이즈 감소
```

---

## 중단: 측정 노이즈 (R)

### 센서 측정 불확실성

```
┌────────────────────────────────────┐
│ GPS 노이즈                          │
├────────────────────────────────────┤
│ EKF2_GPS_V_NOISE = 0.3              │
│  • GPS 속도 노이즈 (m/s)            │
│  • HDOP 고려                       │
│                                    │
│ EKF2_GPS_P_NOISE = 0.5              │
│  • GPS 위치 노이즈 (m)              │
│  • 일반: 0.5 ~ 2.5m                │
│  • RTK:  0.02 ~ 0.3m               │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 기압계 노이즈                       │
├────────────────────────────────────┤
│ EKF2_BARO_NOISE = 2.0               │
│  • 기압 고도 노이즈 (m)             │
│  • 날씨 좋음: 1.0                  │
│  • 날씨 나쁨: 5.0                  │
│  • 프로펠러 풍압: 3.0               │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 지자기 노이즈                       │
├────────────────────────────────────┤
│ EKF2_MAG_NOISE = 0.05               │
│  • 나침반 노이즈 (gauss)            │
│  • 간섭 없음: 0.03                 │
│  • 간섭 많음: 0.1                  │
│  • 실내: 0.2                       │
└────────────────────────────────────┘
```

---

## 오른쪽: Innovation Gate

### 이상값 거부 임계값

```
┌────────────────────────────────────┐
│ Gate 크기 (표준편차 배수)           │
├────────────────────────────────────┤
│ EKF2_GPS_P_GATE = 5.0               │
│  • GPS 위치 게이트 (σ)             │
│  • Innovation < 5σ: 수용            │
│  • Innovation > 5σ: 거부            │
│                                    │
│  예시:                             │
│  불확실성 = 1m                     │
│  Gate = 5m                         │
│  Innovation = 3m → 수용            │
│  Innovation = 7m → 거부            │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 권장 설정                           │
├────────────────────────────────────┤
│ GPS 정확:   3.0σ (엄격)            │
│ GPS 일반:   5.0σ (기본)            │
│ GPS 부정확: 10.0σ (관대)           │
│                                    │
│ 기압계:     5.0σ                   │
│ 지자기:     3.0σ                   │
└────────────────────────────────────┘

너무 엄격: 좋은 데이터도 거부
너무 관대: 나쁜 데이터도 수용
```

---

## 하단: 튜닝 워크플로우

```
┌──────────────────────────────────────┐
│ 1단계: 기본 비행                      │
├──────────────────────────────────────┤
│ • 기본 파라미터로 비행                │
│ • 5분 이상 로그 기록                  │
│ • 다양한 기동 (호버, 전진, 회전)       │
└──────────────────────────────────────┘
         ↓
┌──────────────────────────────────────┐
│ 2단계: 로그 분석                      │
├──────────────────────────────────────┤
│ • ekf2_innovations 토픽 확인          │
│ • Innovation 크기 측정                │
│ • Gate 거부 횟수 확인                 │
└──────────────────────────────────────┘
         ↓
┌──────────────────────────────────────┐
│ 3단계: 파라미터 조정                  │
├──────────────────────────────────────┤
│ Innovation 큰 센서:                   │
│  → 해당 센서 노이즈 증가              │
│                                      │
│ 응답 느린 상태:                      │
│  → 프로세스 노이즈 증가               │
│                                      │
│ Gate 거부 많음:                      │
│  → Gate 크기 증가                    │
└──────────────────────────────────────┘
         ↓
┌──────────────────────────────────────┐
│ 4단계: 검증                          │
├──────────────────────────────────────┤
│ • 새 파라미터로 재비행                │
│ • Innovation 감소 확인                │
│ • 위치 정확도 측정                   │
└──────────────────────────────────────┘
```

---

## 발표 스크립트

"EKF 튜닝은 3종류 파라미터를 조정합니다.

프로세스 노이즈 Q는 시스템 모델의 불확실성입니다. EKF2_ACC_NOISE는 가속도계 노이즈로, 높으면 가속도를 덜 신뢰하고, 낮으면 빠르게 반응하지만 떨립니다. 자이로 바이어스 노이즈는 온도가 안정하면 0.0001로 낮게, 불안정하면 0.01로 높게 설정합니다.

측정 노이즈 R은 센서 측정의 불확실성입니다. GPS는 일반적으로 0.5~2.5m, RTK는 0.02~0.3m입니다. 기압계는 날씨 좋으면 1.0, 나쁘면 5.0, 프로펠러 풍압 있으면 3.0입니다. 지자기는 간섭 없으면 0.03, 많으면 0.1입니다.

Innovation Gate는 이상값 거부 임계값입니다. GPS 위치 게이트가 5.0이면 Innovation이 5σ 이내면 수용하고 초과하면 거부합니다. 예를 들어 불확실성 1m일 때 게이트는 5m이고, Innovation 3m는 수용하지만 7m는 거부합니다. GPS가 정확하면 3σ로 엄격하게, 부정확하면 10σ로 관대하게 설정합니다.

튜닝 워크플로우는 4단계입니다. 먼저 기본 파라미터로 5분 비행하고 로그를 기록합니다. 그 다음 ekf2_innovations 토픽에서 Innovation 크기와 Gate 거부 횟수를 확인합니다. Innovation이 크면 해당 센서 노이즈를 증가시키고, 응답이 느리면 프로세스 노이즈를 증가시킵니다. 마지막으로 새 파라미터로 재비행하여 검증합니다."

---
---

# 슬라이드 41: 요약 및 실습 과제

## 제목
**EKF 센서 융합 요약 및 실습**

## 부제목
이론에서 실전으로

---

## 핵심 요약

### 2단계 프로세스

```
예측 (Prediction)      업데이트 (Update)
IMU 1000Hz         →   GPS 10Hz
     ↓                       ↓
이전 + 물리법칙         예측 + 측정
     ↓                       ↓
현재 상태 예측          최적 추정
(불확실성 증가)        (불확실성 감소)
```

### 24개 상태

```
✓ 자세(4) + 속도(3) + 위치(3) = 핵심 10개
✓ 바이어스(6) = 드리프트 방지
✓ 자기장(6) + 바람(2) = 정확도 향상
```

### 핵심 원리

```
✓ 센서 융합: 장점 활용, 단점 보완
✓ 칼만 게인: 예측 vs 측정 가중치
✓ Innovation Gate: 이상값 거부
✓ 국소 선형화: 비선형 시스템 처리
```

---

## 실습 과제 1: EKF 시뮬레이션

```
┌────────────────────────────────────┐
│ 목표: EKF 알고리즘 직접 구현        │
├────────────────────────────────────┤
│ 1. Python으로 1D 칼만 필터 작성     │
│    • 상태: 위치 + 속도              │
│    • 예측: 등속 운동                │
│    • 측정: 위치만 (노이즈 있음)      │
│                                    │
│ 2. 노이즈 추가                     │
│    • 프로세스 노이즈 Q              │
│    • 측정 노이즈 R                  │
│                                    │
│ 3. 시뮬레이션 실행                 │
│    • 실제 vs 측정 vs 추정 그래프    │
│    • 불확실성(P) 그래프             │
│                                    │
│ 4. 파라미터 변경                   │
│    • Q 증가: 예측 덜 신뢰           │
│    • R 증가: 측정 덜 신뢰           │
│    • 효과 관찰                     │
└────────────────────────────────────┘

예상 시간: 2~3시간
난이도: ★★★☆☆
```

---

## 실습 과제 2: PX4 EKF 로그 분석

```
┌────────────────────────────────────┐
│ 목표: 실제 EKF 동작 관찰            │
├────────────────────────────────────┤
│ 1. PX4 SITL 실행                    │
│                                    │
│ 2. 비행 시나리오                   │
│    • 5분 자율 비행                 │
│    • GPS 끊김 시뮬레이션            │
│      (EKF2_AID_MASK 변경)          │
│                                    │
│ 3. ULog 파일 다운로드               │
│    • .ulg 파일 추출                │
│                                    │
│ 4. Flight Review 분석               │
│    • https://review.px4.io 업로드  │
│    • ekf2_innovations 토픽 확인     │
│    • 센서별 Innovation 그래프       │
│    • Gate 거부 이벤트 확인          │
│                                    │
│ 5. QGroundControl에서 실시간 확인   │
│    • MAVLink Inspector              │
│    • ESTIMATOR_STATUS 메시지        │
│    • 위치 불확실성 모니터링         │
└────────────────────────────────────┘

예상 시간: 2~3시간
난이도: ★★★★☆
```

---

## 실습 과제 3: EKF 파라미터 튜닝

```
┌────────────────────────────────────┐
│ 목표: 최적 파라미터 찾기            │
├────────────────────────────────────┤
│ 1. 기준 비행                       │
│    • 기본 파라미터로 비행           │
│    • Innovation 크기 측정           │
│                                    │
│ 2. GPS 노이즈 조정                 │
│    • EKF2_GPS_P_NOISE 변경          │
│    • 0.5 → 1.0 → 2.0 테스트        │
│    • 위치 정확도 비교               │
│                                    │
│ 3. Gate 크기 조정                  │
│    • EKF2_GPS_P_GATE 변경           │
│    • 3.0 → 5.0 → 10.0 테스트       │
│    • GPS 끊김 시 동작 관찰          │
│                                    │
│ 4. 프로세스 노이즈 조정             │
│    • EKF2_ACC_NOISE 변경            │
│    • 응답 속도 vs 안정성 트레이드오프│
│                                    │
│ 5. 최적 조합 찾기                  │
│    • 여러 조합 테스트               │
│    • 위치 RMS 오차 최소화           │
└────────────────────────────────────┘

예상 시간: 4~5시간
난이도: ★★★★★
```

---

## 실습 환경

### Python 칼만 필터 (추천)

```python
import numpy as np
import matplotlib.pyplot as plt

# 상태: [위치, 속도]
x = np.array([[0.0], [0.0]])
P = np.eye(2) * 1.0

# 시스템 모델
dt = 0.1
F = np.array([[1, dt],
              [0,  1]])
Q = np.array([[0.01, 0   ],
              [0,    0.01]])

# 측정 모델
H = np.array([[1, 0]])
R = np.array([[0.5]])

# 칼만 필터 루프
for t in range(100):
    # 예측
    x = F @ x
    P = F @ P @ F.T + Q
    
    # 측정 (시뮬레이션)
    z = x[0] + np.random.randn() * 0.5
    
    # 업데이트
    y = z - H @ x
    S = H @ P @ H.T + R
    K = P @ H.T @ np.linalg.inv(S)
    x = x + K @ y
    P = (np.eye(2) - K @ H) @ P
    
    # 그래프에 추가
    # ...
```

---

## 추가 학습 자료

```
📚 공식 문서
- PX4 EKF2: https://docs.px4.io/main/en/advanced_config/tuning_the_ecl_ekf.html
- ArduPilot EKF3: https://ardupilot.org/copter/docs/common-apm-navigation-extended-kalman-filter-overview.html

📹 동영상
- Kalman Filter Explained (YouTube)
- PX4 EKF Tuning Tutorial

📖 논문
- "Quaternion-based Extended Kalman Filter for IMU-GPS" 
- "Robust Sensor Fusion for UAV Navigation"

💻 코드 저장소
- PX4 EKF2: src/modules/ekf2/
- ArduPilot: libraries/AP_NavEKF3/
- FilterPy (Python): https://github.com/rlabbe/filterpy
```

---

## 다음 주 예고

```
┌────────────────────────────────────┐
│ 4주차: 경로 계획 (Path Planning)    │
├────────────────────────────────────┤
│ • 그래프 탐색 (A*, Dijkstra)        │
│ • 샘플링 기반 (RRT, PRM)            │
│ • 궤적 최적화                      │
│ • 웨이포인트 추종                  │
│ • 장애물 회피                      │
└────────────────────────────────────┘
```

---

## 발표 스크립트

"EKF를 정리하겠습니다. 핵심은 예측과 업데이트 2단계 프로세스입니다. IMU 1000Hz로 예측하고 GPS 10Hz로 업데이트합니다. 24개 상태는 핵심 10개, 바이어스 6개, 자기장 6개, 바람 2개로 구성됩니다.

실습 과제는 3단계입니다. 먼저 Python으로 1D 칼만 필터를 직접 구현하여 알고리즘을 이해합니다. Q와 R을 변경하며 효과를 관찰합니다.

그 다음 PX4 SITL에서 실제 EKF를 실행하고 로그를 분석합니다. Flight Review에 업로드하여 ekf2_innovations 토픽을 확인하고 GPS 끊김 시 동작을 관찰합니다.

마지막으로 EKF 파라미터를 튜닝합니다. GPS 노이즈, Gate 크기, 프로세스 노이즈를 변경하며 최적 조합을 찾습니다. 위치 RMS 오차를 최소화하는 것이 목표입니다.

Python 칼만 필터 예제 코드를 제공했습니다. 상태는 위치와 속도 2개이고, 예측과 업데이트를 반복합니다.

다음 주에는 경로 계획을 배웁니다. A*, RRT 같은 알고리즘으로 장애물을 피해 목표까지 경로를 찾는 방법을 알아보겠습니다."

---
---

# 🎓 부록: 발표 팁

## 시간 배분 (50분 기준)

```
슬라이드 32-33: 개요 및 센서 (10분)
슬라이드 34-35: 칼만 필터 기초 (10분)
슬라이드 36-38: 24상태 및 예측/업데이트 (15분)
슬라이드 39-40: 실전 및 튜닝 (10분)
슬라이드 41: 요약 및 실습 (5분)
```

## 강조 포인트

```
1. "왜 EKF가 필요한가"
   - 각 센서의 한계
   - 융합의 필요성
   - 시스템의 시작점

2. 수학보다 직관
   - "예측은 불확실, 측정으로 보정"
   - 가우시안 분포 그림 활용
   - 실제 예시 중심

3. 실전 중요성
   - GPS 끊김 시나리오
   - 튜닝의 필요성
   - 로그 분석 방법
```

## 데모 제안

```
라이브 데모 (시간 허락 시):
1. Python 1D 칼만 필터 실행
   - 실시간 그래프
   - Q/R 변경 효과
2. Flight Review
   - 실제 비행 로그
   - Innovation 그래프
3. QGroundControl
   - ESTIMATOR_STATUS
   - 실시간 불확실성
```

---

**훌륭한 강의 되시길 바랍니다! 🚁**
